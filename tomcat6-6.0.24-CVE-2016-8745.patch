--- java/org/apache/coyote/http11/Http11NioProcessor.java.orig	2017-01-16 11:24:34.383647109 -0500
+++ java/org/apache/coyote/http11/Http11NioProcessor.java	2017-01-16 11:29:57.952889821 -0500
@@ -164,6 +164,13 @@
 
 
     /**
+     * Flag that indicates that send file processing is in progress and that the
+     * socket should not be returned to the poller (where a poller is used).
+     */
+    protected boolean sendfileInProgress = false;
+
+
+    /**
      * HTTP/1.1 flag.
      */
     protected boolean http11 = true;
@@ -813,8 +820,8 @@
         error = false;
         keepAlive = true;
         comet = false;
+        sendfileInProgress = false;
         
-
         int keepAliveLeft = maxKeepAliveRequests;
         long soTimeout = endpoint.getSoTimeout();
 
@@ -940,21 +947,12 @@
                 inputBuffer.nextRequest();
                 outputBuffer.nextRequest();
             }
-            
-            // Do sendfile as needed: add socket to sendfile and end
-            if (sendfileData != null && !error) {
-                KeyAttachment ka = (KeyAttachment)socket.getAttachment(false);
-                ka.setSendfileData(sendfileData);
-                sendfileData.keepAlive = keepAlive;
-                SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector());
-                //do the first write on this thread, might as well
-                openSocket = socket.getPoller().processSendfile(key,ka,true,true);
-                break;
-            }
-
 
             rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);
 
+            if (breakKeepAliveLoop(socket)) {            
+                break;
+            }
         }
 
         rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);
@@ -966,15 +964,47 @@
             } else {
                 return SocketState.LONG;
             }
+        } else if (sendfileInProgress) {
+            return SocketState.SENDFILE;
         } else {
-            if ( recycle ) recycle();
-            //return (openSocket) ? (SocketState.OPEN) : SocketState.CLOSED;
+            if (recycle) {
+                recycle();
+            }
             return (openSocket) ? (recycle?SocketState.OPEN:SocketState.LONG) : SocketState.CLOSED;
         }
 
     }
 
 
+    private boolean breakKeepAliveLoop(NioChannel socket) {
+        // Do sendfile as needed: add socket to sendfile and end
+        if (sendfileData != null && !error) {
+            KeyAttachment ka = (KeyAttachment)socket.getAttachment(false);
+            ka.setSendfileData(sendfileData);
+            sendfileData.keepAlive = keepAlive;
+            SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector());
+            //do the first write on this thread, might as well
+            switch (socket.getPoller().processSendfile(key, ka, true)) {
+            case DONE:
+                // If sendfile is complete, no need to break keep-alive loop
+                sendfileData = null;
+                return false;
+            case PENDING:
+                sendfileInProgress = true;
+                return true;
+            case ERROR:
+                // Write failed
+                if (log.isDebugEnabled()) {
+                    log.debug(sm.getString("http11processor.sendfile.error"));
+                }
+                error = true;
+                return true;
+            }
+        }
+        return false;
+    }
+
+
     public void endRequest() {
 
         // Finish the handling of the request
--- java/org/apache/coyote/http11/Http11NioProtocol.java.orig	2017-01-16 11:24:34.384647113 -0500
+++ java/org/apache/coyote/http11/Http11NioProtocol.java	2017-01-16 11:31:19.302218156 -0500
@@ -745,6 +745,12 @@
                     // processor. Continue to poll for the next request
                     release(socket, processor);
                     socket.getPoller().add(socket);
+                } else if (state == SocketState.SENDFILE) {
+                    // Sendfile in progress. If it fails, the socket will be
+                    // closed. If it works, the socket will be re-added to the
+                    // poller
+                    connections.remove(socket);
+                    release(socket, processor);
                 } else {
                     // Connection closed. OK to recycle the processor
                     release(socket, processor);
--- java/org/apache/tomcat/util/net/NioEndpoint.java.orig	2017-01-16 11:52:06.672433970 -0500
+++ java/org/apache/tomcat/util/net/NioEndpoint.java	2017-01-16 11:59:06.183280025 -0500
@@ -1658,7 +1658,7 @@
                     NioChannel channel = attachment.getChannel();
                     if (sk.isReadable() || sk.isWritable() ) {
                         if ( attachment.getSendfileData() != null ) {
-                            processSendfile(sk,attachment,true, false);
+                            processSendfile(sk, attachment, false);
                         } else if ( attachment.getComet() ) {
                             //check if thread is available
                             if ( isWorkerAvailable() ) {
@@ -1703,7 +1703,8 @@
             return result;
         }
         
-        public boolean processSendfile(SelectionKey sk, KeyAttachment attachment, boolean reg, boolean event) {
+        public SendfileState processSendfile(SelectionKey sk, KeyAttachment attachment,
+                boolean calledByProcessor) {
             NioChannel sc = null;
             try {
 					unreg(sk, attachment, sk.readyOps());
@@ -1718,7 +1719,7 @@
                     File f = new File(sd.fileName);
                     if ( !f.exists() ) {
                         cancelledKey(sk,SocketStatus.ERROR,false);
-                        return false;
+                        return SendfileState.ERROR;
                     }
                     sd.fchannel = new FileInputStream(f).getChannel();
                 }
@@ -1755,44 +1756,46 @@
                     }
                     attachment.setSendfileData(null);
                     try {sd.fchannel.close();}catch(Exception ignore){}
-                    if ( sd.keepAlive ) {
-							  if (log.isDebugEnabled()) {
-								  log.debug("Connection is keep alive, registering back for OP_READ");
-							  }
-							  if (event) {
-								  this.add(attachment.getChannel(), SelectionKey.OP_READ);
-							  } else {
-								  reg(sk, attachment, SelectionKey.OP_READ);
-                       }
+                    if (!calledByProcessor) {
+                        if ( sd.keepAlive ) {
+                            if (log.isDebugEnabled()) {
+                                log.debug("Connection is keep alive, registering back for OP_READ");
+                            }
+                            reg(sk, attachment, SelectionKey.OP_READ);
+                        }
                     } else {
                         if (log.isDebugEnabled()) {
                             log.debug("Send file connection is being closed");
                         }
                         cancelledKey(sk,SocketStatus.STOP,false);
-								return false;
                     }
+                    return SendfileState.DONE;
                 } else {
                     if (log.isDebugEnabled()) {
                         log.debug("OP_WRITE for sendilfe:" + sd.fileName);
                     }
-                    if (event) {
+                    if (calledByProcessor) {
                         add(attachment.getChannel(),SelectionKey.OP_WRITE);
                     } else {
                         reg(sk,attachment,SelectionKey.OP_WRITE);
                     }
+                    return SendfileState.PENDING;
                 }
             }catch ( IOException x ) {
                 if ( log.isDebugEnabled() ) log.debug("Unable to complete sendfile request:", x);
-                cancelledKey(sk,SocketStatus.ERROR,false);
-                return false;
+                if (!calledByProcessor) {
+                    cancelledKey(sk,SocketStatus.ERROR,false);
+                }
+                return SendfileState.ERROR;
             }catch ( Throwable t ) {
                 log.error("",t);
-                cancelledKey(sk, SocketStatus.ERROR, false);
-                return false;
+                if (!calledByProcessor) {
+                    cancelledKey(sk, SocketStatus.ERROR, false);
+                }
+                return SendfileState.ERROR;
             }finally {
                 if (sc!=null) sc.setSendFile(false);
             }
-            return true;
         }
 
         protected void unreg(SelectionKey sk, KeyAttachment attachment, int readyOps) {
@@ -2146,7 +2149,7 @@
      */
     public interface Handler {
         public enum SocketState {
-            OPEN, CLOSED, LONG
+            OPEN, CLOSED, LONG, SENDFILE
         }
         public SocketState process(NioChannel socket);
         public SocketState event(NioChannel socket, SocketStatus status);
--- webapps/docs/changelog.xml.orig	2017-01-16 14:02:59.131014997 -0500
+++ webapps/docs/changelog.xml	2017-01-16 14:02:27.200887198 -0500
@@ -43,6 +43,16 @@
 <!-- Section names:
  General, Catalina, Coyote, Jasper, Cluster, Web applications, Other
 -->
+<section name="Tomcat 6.0.24-100 (csutherl)">
+  <subsection name="Coyote">
+    <changelog>
+      <fix>
+        <bug>60409</bug>: When unable to complete sendfile request, ensure the
+        Processor will be added to the cache only once. (markt/violetagg)
+      </fix>
+    </changelog>
+  </subsection>
+</section>
 <section name="Tomcat 6.0.24-98 (csutherl)">
   <subsection name="Catalina">
     <changelog>
--- java/org/apache/tomcat/util/net/SendfileState.java.orig	2017-01-16 11:24:34.387647125 -0500
+++ java/org/apache/tomcat/util/net/SendfileState.java	2017-01-16 11:24:34.390647136 -0500
@@ -0,0 +1,37 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.tomcat.util.net;
+
+public enum SendfileState {
+
+    /**
+     * The sending of the file has started but has not completed. Sendfile is
+     * still using the socket.
+     */
+    PENDING,
+
+    /**
+     * The file has been fully sent. Sendfile is no longer using the socket.
+     */
+    DONE,
+
+    /**
+     * Something went wrong. The file may or may not have been sent. The socket
+     * is in an unknown state.
+     */
+    ERROR
+}
