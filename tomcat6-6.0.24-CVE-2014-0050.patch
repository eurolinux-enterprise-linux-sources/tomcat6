--- java/org/apache/tomcat/util/http/fileupload/MultipartStream.java.orig	2014-06-03 11:57:44.577297000 -0400
+++ java/org/apache/tomcat/util/http/fileupload/MultipartStream.java	2014-06-04 14:57:23.852090000 -0400
@@ -107,24 +107,34 @@
 
 
     /**
+     * character values used for separators
+     */
+    public static final byte CR = 0x0D;
+    public static final byte LF = 0x0A;
+    public static final byte DASH = 0x2D;
+
+    /**
      * A byte sequence that marks the end of <code>header-part</code>
      * (<code>CRLFCRLF</code>).
      */
-    protected static final byte[] HEADER_SEPARATOR = {0x0D, 0x0A, 0x0D, 0x0A};
-
+    protected static final byte[] HEADER_SEPARATOR = {CR, LF, CR, LF};
 
     /**
      * A byte sequence that that follows a delimiter that will be
      * followed by an encapsulation (<code>CRLF</code>).
      */
-    protected static final byte[] FIELD_SEPARATOR = { 0x0D, 0x0A };
-
+    protected static final byte[] FIELD_SEPARATOR = {CR, LF};
 
     /**
      * A byte sequence that that follows a delimiter of the last
      * encapsulation in the stream (<code>--</code>).
      */
-    protected static final byte[] STREAM_TERMINATOR = { 0x2D, 0x2D };
+    protected static final byte[] STREAM_TERMINATOR = { DASH, DASH};
+
+    /**
+     * A byte sequence that precedes a boundry <code>CRLF</code>
+     */
+    protected static final byte[] BOUNDARY_PREFIX = {CR, LF, DASH, DASH};
 
 
     // ----------------------------------------------------------- Data members
@@ -225,6 +235,7 @@
     public MultipartStream(InputStream input,
                            byte[] boundary,
                            int bufSize)
+        throws IllegalArgumentException
     {
         this.input = input;
         this.bufSize = bufSize;
@@ -232,14 +243,18 @@
 
         // We prepend CR/LF to the boundary to chop trailng CR/LF from
         // body-data tokens.
-        this.boundary = new byte[boundary.length + 4];
-        this.boundaryLength = boundary.length + 4;
-        this.keepRegion = boundary.length + 3;
-        this.boundary[0] = 0x0D;
-        this.boundary[1] = 0x0A;
-        this.boundary[2] = 0x2D;
-        this.boundary[3] = 0x2D;
-        System.arraycopy(boundary, 0, this.boundary, 4, boundary.length);
+        this.boundaryLength = boundary.length + BOUNDARY_PREFIX.length;
+        if (bufSize < this.boundaryLength + 1) {
+            throw new IllegalArgumentException(
+              "The buffer size specified for the MultipartStream is too small");
+        }
+        this.boundary = new byte[this.boundaryLength];
+        this.keepRegion = this.boundary.length;
+
+        System.arraycopy(BOUNDARY_PREFIX, 0, this.boundary, 0, 
+                BOUNDARY_PREFIX.length);
+        System.arraycopy(boundary, 0, this.boundary, BOUNDARY_PREFIX.length,
+                boundary.length);
 
         head = 0;
         tail = 0;
@@ -389,12 +404,13 @@
     public void setBoundary(byte[] boundary)
         throws IllegalBoundaryException
     {
-        if (boundary.length != boundaryLength - 4)
+        if (boundary.length != boundaryLength - BOUNDARY_PREFIX.length)
         {
             throw new IllegalBoundaryException(
                     "The length of a boundary token can not be changed");
         }
-        System.arraycopy(boundary, 0, this.boundary, 4, boundary.length);
+        System.arraycopy(boundary, 0, this.boundary, BOUNDARY_PREFIX.length, 
+            boundary.length);
     }
 
 
@@ -414,26 +430,30 @@
      * @exception MalformedStreamException if the stream ends unexpecetedly.
      */
     public String readHeaders()
-        throws MalformedStreamException
+        throws FileUploadException, MalformedStreamException
     {
         int i = 0;
-        byte b[] = new byte[1];
+        byte b; 
         // to support multi-byte characters
         ByteArrayOutputStream baos = new ByteArrayOutputStream();
-        int sizeMax = HEADER_PART_SIZE_MAX;
         int size = 0;
-        while (i < 4)
+        while (i < HEADER_SEPARATOR.length)
         {
             try
             {
-                b[0] = readByte();
-            }
-            catch (IOException e)
+                b = readByte();
+            } catch (IOException e)
             {
                 throw new MalformedStreamException("Stream ended unexpectedly");
             }
-            size++;
-            if (b[0] == HEADER_SEPARATOR[i])
+            if (++size > HEADER_PART_SIZE_MAX) {
+                throw new MalformedStreamException(String.format(
+                            "Header section has more thant %s bytes ( " +
+                            " maybe it is not properly terminated)", 
+                    Integer.valueOf(HEADER_PART_SIZE_MAX)));
+            }
+
+            if (b == HEADER_SEPARATOR[i])
             {
                 i++;
             }
@@ -441,10 +461,7 @@
             {
                 i = 0;
             }
-            if (size <= sizeMax)
-            {
-                baos.write(b[0]);
-            }
+            baos.write(b);
         }
 
         String headers = null;
@@ -658,8 +675,8 @@
             // Restore delimiter.
             System.arraycopy(boundary, 0, boundary, 2, boundary.length - 2);
             boundaryLength = boundary.length;
-            boundary[0] = 0x0D;
-            boundary[1] = 0x0A;
+            boundary[0] = CR;
+            boundary[1] = LF;
         }
     }
 
--- java/org/apache/tomcat/util/http/fileupload/FileUploadBase.java.orig	2014-04-10 17:24:08.006085000 -0400
+++ java/org/apache/tomcat/util/http/fileupload/FileUploadBase.java	2014-06-04 13:18:09.332028000 -0400
@@ -278,8 +278,7 @@
         try
         {
             int boundaryIndex = contentType.indexOf("boundary=");
-            if (boundaryIndex < 0)
-            {
+            if (boundaryIndex < 0) {
                 throw new FileUploadException(
                         "the request was rejected because "
                         + "no multipart boundary was found");
@@ -288,8 +287,16 @@
                     boundaryIndex + 9).getBytes();
 
             InputStream input = req.getInputStream();
-
-            MultipartStream multi = new MultipartStream(input, boundary);
+            MultipartStream multi = null;
+            try {
+                multi =  new MultipartStream(input, boundary);
+            } catch (IllegalArgumentException iae) {
+                throw new InvalidContentTypeException( 
+                        "The boundary specified in the " +
+                        CONTENT_TYPE + "header is too long", iae);
+            }
+            
+                
             multi.setHeaderEncoding(headerEncoding);
 
             boolean nextPart = multi.skipPreamble();
@@ -570,6 +577,10 @@
             super();
         }
 
+        public InvalidContentTypeException(String msg, Throwable cause) {
+            super(msg, cause);
+        }
+
         /**
          * Constructs an <code>InvalidContentTypeException</code> with
          * the specified detail message.
--- java/org/apache/tomcat/util/http/fileupload/FileUploadException.java.orig	2014-04-13 13:05:12.578540000 -0400
+++ java/org/apache/tomcat/util/http/fileupload/FileUploadException.java	2014-04-13 13:08:42.918232000 -0400
@@ -46,4 +46,16 @@
     {
         super(msg);
     }
+
+    /**
+     * Constructs a new <code>FileUploadException</code> with the 
+     * provided message and <code>Throwable</code> cause.
+     *
+     * @param msg the exception message
+     * @param cause the originating cause for the exception condition
+     */
+    public FileUploadException(String msg, Throwable cause)
+    {
+        super(msg, cause);
+    }
 }
--- webapps/docs/changelog.xml.orig	2014-04-10 17:11:46.332580000 -0400
+++ webapps/docs/changelog.xml	2014-04-10 17:22:21.119715000 -0400
@@ -37,6 +37,11 @@
   <subsection name="Catalina">
     <changelog>
         <fix>
+            Fix CVE-2014-0050 a denial of service with a malicious, 
+            malformed Content-Type header and multipart request 
+            processing. Patch applied by Red Hat
+        </fix>
+        <fix>
             Add support for limiting the size of chunk extensions when 
             using chunked encoding. (markt) CVE-2013-4322 patch applied by
             Red Hat
