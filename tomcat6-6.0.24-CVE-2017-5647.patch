--- java/org/apache/coyote/http11/Http11NioProcessor.java.orig	2017-06-08 07:56:52.023933360 -0400
+++ java/org/apache/coyote/http11/Http11NioProcessor.java	2017-06-08 11:53:53.013325634 -0400
@@ -49,6 +49,7 @@
 import org.apache.tomcat.util.net.NioChannel;
 import org.apache.tomcat.util.net.NioEndpoint;
 import org.apache.tomcat.util.net.SSLSupport;
+import org.apache.tomcat.util.net.SendfileKeepAliveState;
 import org.apache.tomcat.util.net.SocketStatus;
 import org.apache.tomcat.util.net.NioEndpoint.Handler.SocketState;
 import org.apache.tomcat.util.res.StringManager;
@@ -981,7 +982,15 @@
         if (sendfileData != null && !error) {
             KeyAttachment ka = (KeyAttachment)socket.getAttachment(false);
             ka.setSendfileData(sendfileData);
-            sendfileData.keepAlive = keepAlive;
+            if (keepAlive) {
+                if (inputBuffer.available() == 0) {
+                    sendfileData.keepAliveState = SendfileKeepAliveState.OPEN;
+                } else {
+                    sendfileData.keepAliveState = SendfileKeepAliveState.PIPELINED;
+                }
+            } else {
+                sendfileData.keepAliveState = SendfileKeepAliveState.NONE;
+            }
             SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector());
             //do the first write on this thread, might as well
             switch (socket.getPoller().processSendfile(key, ka, true)) {
--- java/org/apache/coyote/http11/Http11NioProtocol.java.orig	2017-06-08 07:56:52.024933361 -0400
+++ java/org/apache/coyote/http11/Http11NioProtocol.java	2017-06-08 12:33:59.450703790 -0400
@@ -747,10 +747,10 @@
                     socket.getPoller().add(socket);
                 } else if (state == SocketState.SENDFILE) {
                     // Sendfile in progress. If it fails, the socket will be
-                    // closed. If it works, the socket will be re-added to the
-                    // poller
-                    connections.remove(socket);
-                    release(socket, processor);
+                    // closed. If it works, the socket either be added to the
+                    // poller to await more data or processed if there are any
+                    // pipe-lined requests remaining.
+                    connections.put(socket, processor);
                 } else {
                     // Connection closed. OK to recycle the processor
                     release(socket, processor);
--- java/org/apache/tomcat/util/net/NioEndpoint.java.orig	2017-06-08 07:56:52.026933365 -0400
+++ java/org/apache/tomcat/util/net/NioEndpoint.java	2017-06-08 12:49:21.037547246 -0400
@@ -1757,17 +1757,31 @@
                     attachment.setSendfileData(null);
                     try {sd.fchannel.close();}catch(Exception ignore){}
                     if (!calledByProcessor) {
-                        if ( sd.keepAlive ) {
+                        switch (sd.keepAliveState) {
+                        case NONE: {
+                            if (log.isDebugEnabled()) {
+                                log.debug("Send file connection is being closed");
+                            }
+                            cancelledKey(sk,SocketStatus.STOP,false);
+                            break;
+                        }
+                        case PIPELINED: {
+                            if (log.isDebugEnabled()) {
+                                log.debug("Connection is keep alive, processing pipe-lined data");
+                            }
+                            if (!processSocket(sc, null, true)) {
+                                cancelledKey(sk, SocketStatus.DISCONNECT, false);
+                            }
+                            break;
+                        }
+                        case OPEN: {
                             if (log.isDebugEnabled()) {
                                 log.debug("Connection is keep alive, registering back for OP_READ");
                             }
                             reg(sk, attachment, SelectionKey.OP_READ);
+                            break;
                         }
-                    } else {
-                        if (log.isDebugEnabled()) {
-                            log.debug("Send file connection is being closed");
                         }
-                        cancelledKey(sk,SocketStatus.STOP,false);
                     }
                     return SendfileState.DONE;
                 } else {
@@ -2408,7 +2422,7 @@
         public long pos;
         public long length;
         // KeepAlive flag
-        public boolean keepAlive;
+        public SendfileKeepAliveState keepAliveState = SendfileKeepAliveState.NONE;
     }
 
 }
--- java/org/apache/coyote/http11/Http11AprProcessor.java.orig	2017-06-08 07:56:52.027933367 -0400
+++ java/org/apache/coyote/http11/Http11AprProcessor.java	2017-06-08 12:49:56.245655938 -0400
@@ -53,6 +53,7 @@
 import org.apache.tomcat.util.http.FastHttpDateFormat;
 import org.apache.tomcat.util.http.MimeHeaders;
 import org.apache.tomcat.util.net.AprEndpoint;
+import org.apache.tomcat.util.net.SendfileKeepAliveState;
 import org.apache.tomcat.util.net.SocketStatus;
 import org.apache.tomcat.util.net.AprEndpoint.Handler.SocketState;
 import org.apache.tomcat.util.res.StringManager;
@@ -805,6 +806,7 @@
         
         boolean keptAlive = false;
         boolean openSocket = false;
+        boolean sendfileInProgress = false;
 
         while (!error && keepAlive && !comet) {
 
@@ -818,8 +820,6 @@
                     // (long keepalive), so that the processor should be recycled
                     // and the method should return true
                     openSocket = true;
-                    // Add the socket to the poller
-                    endpoint.getPoller().add(socket);
                     break;
                 }
                 request.setStartTime(System.currentTimeMillis());
@@ -908,7 +908,15 @@
             // Do sendfile as needed: add socket to sendfile and end
             if (sendfileData != null && !error) {
                 sendfileData.socket = socket;
-                sendfileData.keepAlive = keepAlive;
+                if (keepAlive) {
+                    if (inputBuffer.available() == 0) {
+                        sendfileData.keepAliveState = SendfileKeepAliveState.OPEN;
+                    } else {
+                        sendfileData.keepAliveState = SendfileKeepAliveState.PIPELINED;
+                    }
+                } else {
+                    sendfileData.keepAliveState = SendfileKeepAliveState.NONE;
+                }
                 if (!endpoint.getSendfile().add(sendfileData)) {
 						 if (sendfileData.socket == 0) {
 							 // Didn't send all the data but the socket is no longer
@@ -920,7 +928,7 @@
 							 }
 							 error = true;
 						 } else {
-							 openSocket = true;
+                             sendfileInProgress = true;
 						 }
                   break;
                 }
@@ -941,6 +949,8 @@
             } else {
                 return SocketState.LONG;
             }
+        } else if (sendfileInProgress) {
+            return SocketState.SENDFILE;
         } else {
             recycle();
             return (openSocket) ? SocketState.OPEN : SocketState.CLOSED;
--- java/org/apache/tomcat/util/net/AprEndpoint.java.orig	2017-06-08 07:56:52.029933370 -0400
+++ java/org/apache/tomcat/util/net/AprEndpoint.java	2017-06-08 13:13:52.518203256 -0400
@@ -21,6 +21,8 @@
 import java.net.InetSocketAddress;
 import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.Executor;
 
 import org.apache.juli.logging.Log;
@@ -156,7 +158,9 @@
      */
     protected long sslContext = 0;
 
-    
+    private Map<Long,Object> locks = new ConcurrentHashMap<Long, Object>();
+
+
     // ------------------------------------------------------------- Properties
 
 
@@ -607,7 +611,7 @@
 
         if (initialized)
             return;
-        
+
         // Create the root APR memory pool
         rootPool = Pool.create(0);
         // Create the pool for the server socket
@@ -1068,6 +1072,8 @@
      * Process given socket.
      */
     protected boolean processSocketWithOptions(long socket) {
+        Long key = Long.valueOf(socket);
+        locks.put(key, new Object());
         try {
             if (executor == null) {
                 getWorkerThread().assignWithOptions(socket);
@@ -1078,6 +1084,7 @@
             // This means we got an OOM or similar creating a thread, or that
             // the pool and its queue are full
             log.error(sm.getString("endpoint.process.fail"), t);
+            locks.remove(key);
             return false;
         }
         return true;
@@ -1122,6 +1129,17 @@
         }
         return true;
     }
+
+    private void destroySocket(long socket) {
+        Long key = Long.valueOf(socket);
+        locks.remove(key);
+        if (running && socket != 0) {
+            // If not running the socket will be destroyed by
+            // parent pool or acceptor socket.
+            // In any case disable double free which would cause JVM core.
+            Socket.destroy(socket);
+        }
+    }
     
 
     // --------------------------------------------------- Acceptor Inner Class
@@ -1547,16 +1565,21 @@
                     }
                 } else {
 
-                    // Process the request from this socket
-                    if ((status != null) && (handler.event(socket, status) == Handler.SocketState.CLOSED)) {
-                        // Close socket and pool
-                        Socket.destroy(socket);
-                        socket = 0;
-                    } else if ((status == null) && ((options && !setSocketOptions(socket)) 
-                            || handler.process(socket) == Handler.SocketState.CLOSED)) {
-                        // Close socket and pool
-                        Socket.destroy(socket);
-                        socket = 0;
+                    Long key = Long.valueOf(socket);
+                    Object lock = locks.get(key);
+
+                    synchronized (lock) {
+                        // Process the request from this socket
+                        if ((status != null) && (handler.event(socket, status) == Handler.SocketState.CLOSED)) {
+                            // Close socket and pool
+                            destroySocket(socket);
+                            socket = 0;
+                        } else if ((status == null) && ((options && !setSocketOptions(socket))
+                                || handler.process(socket) == Handler.SocketState.CLOSED)) {
+                            // Close socket and pool
+                            destroySocket(socket);
+                            socket = 0;
+                        }
                     }
                 }
 
@@ -1601,7 +1624,7 @@
         // Position
         public long pos;
         // KeepAlive flag
-        public boolean keepAlive;
+        public SendfileKeepAliveState keepAliveState = SendfileKeepAliveState.NONE;
     }
 
 
@@ -1831,17 +1854,32 @@
                             state.pos = state.pos + nw;
                             if (state.pos >= state.end) {
                                 remove(state);
-                                if (state.keepAlive) {
+                                switch (state.keepAliveState) {
+                                case NONE: {
+                                    // Close the socket since this is
+                                    // the end of the not keep-alive request.
+                                    destroySocket(state.socket);
+                                    break;
+                                }
+                                case PIPELINED: {
                                     // Destroy file descriptor pool, which should close the file
                                     Pool.destroy(state.fdpool);
                                     Socket.timeoutSet(state.socket, soTimeout * 1000);
-                                    // If all done put the socket back in the poller for
+                                    // Process the pipelined request data
+                                    if (!processSocket(state.socket, null)) {
+                                        destroySocket(state.socket);
+                                    }
+                                    break;
+                                }
+                                case OPEN: {
+                                    // Destroy file descriptor pool, which should close the file
+                                    Pool.destroy(state.fdpool);
+                                    Socket.timeoutSet(state.socket, soTimeout * 1000);
+                                    // Put the socket back in the poller for
                                     // processing of further requests
                                     getPoller().add(state.socket);
-                                } else {
-                                    // Close the socket since this is
-                                    // the end of not keep-alive request.
-                                    Socket.destroy(state.socket);
+                                    break;
+                                }
                                 }
                             }
                         }
@@ -1901,7 +1939,7 @@
      */
     public interface Handler {
         public enum SocketState {
-            OPEN, CLOSED, LONG
+            OPEN, CLOSED, LONG, SENDFILE
         }
         public SocketState process(long socket);
         public SocketState event(long socket, SocketStatus status);
@@ -2014,16 +2052,19 @@
                 }
             } else {
                 // Process the request from this socket
-                if (!setSocketOptions(socket) 
-                        || handler.process(socket) == Handler.SocketState.CLOSED) {
-                    // Close socket and pool
-                    Socket.destroy(socket);
-                    socket = 0;
+                Long key = Long.valueOf(socket);
+                Object lock = locks.get(key);
+
+                synchronized (lock) {
+                    if (!setSocketOptions(socket)
+                            || handler.process(socket) == Handler.SocketState.CLOSED) {
+                        // Close socket and pool
+                        destroySocket(socket);
+                        socket = 0;
+                    }
                 }
             }
-
         }
-        
     }
     
     
@@ -2044,13 +2085,17 @@
 
         public void run() {
 
-            // Process the request from this socket
-            if (handler.process(socket) == Handler.SocketState.CLOSED) {
-                // Close socket and pool
-                Socket.destroy(socket);
-                socket = 0;
-            }
+            Long key = Long.valueOf(socket);
+            Object lock = locks.get(key);
 
+            synchronized (lock) {
+                // Process the request from this socket
+                if (handler.process(socket) == Handler.SocketState.CLOSED) {
+                    // Close socket and pool
+                    destroySocket(socket);
+                    socket = 0;
+                }
+            }
         }
         
     }
@@ -2075,13 +2120,17 @@
 
         public void run() {
 
-            // Process the request from this socket
-            if (handler.event(socket, status) == Handler.SocketState.CLOSED) {
-                // Close socket and pool
-                Socket.destroy(socket);
-                socket = 0;
-            }
+            Long key = Long.valueOf(socket);
+            Object lock = locks.get(key);
 
+            synchronized (lock) {
+                // Process the request from this socket
+                if (handler.event(socket, status) == Handler.SocketState.CLOSED) {
+                    // Close socket and pool
+                    destroySocket(socket);
+                    socket = 0;
+                }
+            }
         }
         
     }
--- webapps/docs/changelog.xml.orig	2017-06-08 14:53:48.496945372 -0400
+++ webapps/docs/changelog.xml	2017-06-08 14:54:49.388172684 -0400
@@ -43,6 +43,18 @@
 <!-- Section names:
  General, Catalina, Coyote, Jasper, Cluster, Web applications, Other
 -->
+<section name="Tomcat 6.0.24-106 (csutherl)">
+  <subsection name="Coyote">
+    <changelog>
+      <fix>
+        Improve sendfile handling when requests are pipelined. (markt)
+      </fix>
+      <fix>
+        Ensure that the socket is returned only once to the poller. (violetagg)
+      </fix>
+    </changelog>
+  </subsection>
+</section>
 <section name="Tomcat 6.0.24-105 (csutherl)">
   <subsection name="Catalina">
     <changelog>
--- java/org/apache/coyote/http11/Http11AprProtocol.java.orig	2017-06-08 13:32:28.782913047 -0400
+++ java/org/apache/coyote/http11/Http11AprProtocol.java	2017-06-08 12:33:34.990628491 -0400
@@ -566,8 +566,14 @@
         }
         
         public SocketState process(long socket) {
-            Http11AprProcessor processor = recycledProcessors.poll();
+            Http11AprProcessor processor = null;
             try {
+                processor = connections.remove(Long.valueOf(socket));
+
+                if (processor == null) {
+                    processor = recycledProcessors.poll();
+                }
+
                 if (processor == null) {
                     processor = createProcessor();
                 }
@@ -583,6 +589,17 @@
                     // processor.
                     connections.put(socket, processor);
                     proto.endpoint.getCometPoller().add(socket);
+                } else if (state == SocketState.OPEN) {
+                    // In keep-alive but between requests. OK to recycle
+                    // processor. Continue to poll for the next request.
+                    recycledProcessors.offer(processor);
+                    proto.endpoint.getPoller().add(socket);
+                } else if (state == SocketState.SENDFILE) {
+                    // Sendfile in progress. If it fails, the socket will be
+                    // closed. If it works, the socket either be added to the
+                    // poller to await more data or processed if there are any
+                    // pipe-lined requests remaining.
+                    connections.put(socket, processor);
                 } else {
                     recycledProcessors.offer(processor);
                 }
--- java/org/apache/tomcat/util/net/SendfileKeepAliveState.java.orig	2017-06-08 07:56:52.034933379 -0400
+++ java/org/apache/tomcat/util/net/SendfileKeepAliveState.java	2017-06-08 12:20:58.683300215 -0400
@@ -0,0 +1,39 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.tomcat.util.net;
+
+public enum SendfileKeepAliveState {
+
+    /**
+     * Keep-alive is not in use. The socket can be closed when the response has
+     * been written.
+     */
+    NONE,
+
+    /**
+     * Keep-alive is in use and there is pipelined data in the input buffer to
+     * be read as soon as the current response has been written.
+     */
+    PIPELINED,
+
+    /**
+     * Keep-alive is in use. The socket should be added to the poller (or
+     * equivalent) to await more data as soon as the current response has been
+     * written.
+     */
+    OPEN
+}
