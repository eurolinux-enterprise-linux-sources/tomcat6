--- java/org/apache/coyote/Constants.java.orig	2015-02-02 14:02:28.643810000 -0500
+++ java/org/apache/coyote/Constants.java	2015-02-02 14:02:28.572814000 -0500
@@ -68,4 +68,21 @@
                 "org.apache.coyote.USE_CUSTOM_STATUS_MSG_IN_HEADER",
                 "false")).booleanValue(); 
 
+     /**
+      * Limit on the total length of the trailer headers in
+      * a chunked HTTP request.
+      */
+     public static final int MAX_TRAILER_SIZE =
+         Integer.parseInt(System.getProperty(
+             "org.apache.coyote.MAX_TRAILER_SIZE",
+             "8192"));
+  
+    /**
+     * Limit on the total length of the extension data in
+     * a chunked HTTP request.
+     */
+    public static final int MAX_EXTENSION_SIZE =
+        Integer.parseInt(System.getProperty(
+            "org.apache.coyote.MAX_EXTENSION_SIZE",
+            "8192")); 
 }
--- java/org/apache/coyote/http11/filters/ChunkedInputFilter.java.orig	2015-02-02 14:02:28.369807000 -0500
+++ java/org/apache/coyote/http11/filters/ChunkedInputFilter.java	2015-02-25 14:00:23.535744000 -0500
@@ -17,16 +17,19 @@
 
 package org.apache.coyote.http11.filters;
 
+import java.io.EOFException;
 import java.io.IOException;
 
 import org.apache.tomcat.util.buf.ByteChunk;
 import org.apache.tomcat.util.buf.HexUtils;
-
+import org.apache.tomcat.util.buf.MessageBytes;
+import org.apache.tomcat.util.http.MimeHeaders;
 import org.apache.coyote.InputBuffer;
 import org.apache.coyote.Request;
 import org.apache.coyote.http11.Constants;
 import org.apache.coyote.http11.InputFilter;
 
+
 /**
  * Chunked input filter. Parses chunked data according to
  * <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.6.1">http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.6.1</a><br>
@@ -90,17 +93,32 @@
      */
     protected ByteChunk readChunk = new ByteChunk();
 
+    /**
+     * Flag set to true if the next call to doRead must parse a 
+     * CRLF pair before doing anything else
+     */
+    protected boolean needCRLFParse = false;
 
     /**
-     * Flag set to true when the end chunk has been read.
+     * Size of extensions processed for a request
      */
-    protected boolean endChunk = false;
+    private long extensionSize;
 
     /**
-     * Flag set to true if the next call to doRead() must parse a CRLF pair
-     * before doing anything else.
+     * Flag set to true when the end chunk has been read.
      */
-    protected boolean needCRLFParse = false;
+    protected boolean endChunk = false;
+
+    private ByteChunk trailingHeaders;
+    {
+        trailingHeaders = new ByteChunk();
+        if (org.apache.coyote.Constants.MAX_TRAILER_SIZE > 0) {
+            trailingHeaders.setLimit(
+                org.apache.coyote.Constants.MAX_TRAILER_SIZE);
+        }
+    }
+
+    private Request request = null;
 
     // ------------------------------------------------------------- Properties
 
@@ -119,7 +137,8 @@
      */
     public int doRead(ByteChunk chunk, Request req)
         throws IOException {
-
+     
+        //this.request = req;
         if (endChunk)
             return -1;
 
@@ -156,7 +175,6 @@
             remaining = 0;
             //we need a CRLF
             if ((pos+1) >= lastValid) {   
-                //if we call parseCRLF we overrun the buffer here
                 //so we defer it to the next call BZ 11117
                 needCRLFParse = true;
             } else {
@@ -176,6 +194,7 @@
      * Read the content length from the request.
      */
     public void setRequest(Request request) {
+         this.request = request;
     }
 
 
@@ -219,6 +238,15 @@
         pos = 0;
         lastValid = 0;
         endChunk = false;
+        needCRLFParse = false;
+        trailingHeaders.recycle();
+        if (org.apache.coyote.Constants.MAX_TRAILER_SIZE > 0) {
+            trailingHeaders.setLimit(
+                org.apache.coyote.Constants.MAX_TRAILER_SIZE);
+        }
+        extensionSize = 0;
+        request = null;
+
     }
 
 
@@ -265,7 +293,7 @@
         int result = 0;
         boolean eol = false;
         boolean readDigit = false;
-        boolean trailer = false;
+        boolean extension = false;
 
         while (!eol) {
 
@@ -274,15 +302,19 @@
                     return false;
             }
 
-            if (buf[pos] == Constants.CR) {
-            } else if (buf[pos] == Constants.LF) {
+            if (buf[pos] == Constants.CR || buf[pos] == Constants.LF) {
+                parseCRLF(false);
                 eol = true;
-            } else if (buf[pos] == Constants.SEMI_COLON) {
-                trailer = true;
-            } else if (!trailer) { 
-                //don't read data after the trailer
-					 int charValue  = HexUtils.getDec(buf[pos]);
-					 if (charValue != -1)  {
+            } else if (buf[pos] == Constants.SEMI_COLON && !extension) {
+             // First semi-colon marks the start of the extension. Further
+             // semi-colons may appear to separate multiple chunk-extensions.
+             // These need to be processed as part of parsing the extensions.
+                extension = true;
+                extensionSize++;
+            } else if (!extension) { 
+             //don't read data after the trailer
+		int charValue  = HexUtils.getDec(buf[pos]);
+		if (charValue != -1)  {
                     readDigit = true;
                     result *= 16;
                     result += charValue;
@@ -291,9 +323,20 @@
                     //in the chunked header
                     return false;
                 }
+            } else {
+                // Extension parsing
+                // Note that the chunk-extension is neither parsed nor
+                // validated. Currently it is simply ignored.
+                extensionSize++;
+                if (org.apache.coyote.Constants.MAX_EXTENSION_SIZE > -1 &&
+                    extensionSize > org.apache.coyote.Constants.MAX_EXTENSION_SIZE)
+                { 
+                    throw new IOException("maxExtensionSize exceeded");
+                }
+            }
+            if (!eol) {
+                pos++;
             }
-
-            pos++;
 
         }
 
@@ -318,6 +361,14 @@
     protected boolean parseCRLF()
         throws IOException {
 
+        parseCRLF(false);
+        return true;
+    }
+
+    protected void parseCRLF(boolean tolerant)
+        throws IOException
+    {
+
         boolean eol = false;
         boolean crfound = false;
 
@@ -332,7 +383,10 @@
                 if (crfound) throw new IOException("Invalid CRLF, two CR characters encountered.");
                 crfound = true;
             } else if (buf[pos] == Constants.LF) {
-                if (!crfound) throw new IOException("Invalid CRLF, no CR character encountered.");
+                if (!crfound && !tolerant) {
+                    throw new IOException(
+                            "Invalid CRLF, no CR character encountered.");
+                }
                 eol = true;
             } else {
                 throw new IOException("Invalid CRLF");
@@ -342,21 +396,169 @@
 
         }
 
-        return true;
-
     }
 
 
     /**
      * Parse end chunk data.
-     * FIXME: Handle trailers
+     * 
      */
     protected boolean parseEndChunk()
         throws IOException {
+        // Handle optional trailer headers
+        while (parseHeader()) {
+            // Loop until we run out of headers
+        }
+
+        return true;
+    }
+
 
-        return parseCRLF(); // FIXME
+    private boolean parseHeader() 
+        throws IOException {
+        
+        MimeHeaders headers = request.getMimeHeaders();
+        byte chr = 0;
 
+        // Read new bytes if needed
+        if (pos >= lastValid) {
+            if (readBytes() > 0)
+                throw new EOFException(
+                    "Unexpected end of stream while reading trailer headers for chunked request");
+        }
+
+        chr = buf[pos];
+
+        //CRLF terminates the request
+        if (chr == Constants.CR || chr == Constants.LF)
+        {
+            parseCRLF(false);
+            return false;
+        }
+        // Mark the current buffer position
+        int start = trailingHeaders.getEnd();
+
+
+        // 
+        // Reading the header name
+        // Header name is always US-ASCII
+        //
+        boolean colon = false;
+        while (!colon) {
+            // Read bytes if needed
+            if (pos >= lastValid) {
+                if (readBytes() < 0)
+                    throw new EOFException(
+                        "Unexpected end of stream while reading trailer " +
+                       " headers for chunked request");
+            }
+            chr = buf[pos];
+
+            if ((chr >= Constants.A) && (chr <= Constants.Z)) {
+                chr = (byte) (chr - Constants.LC_OFFSET);
+            }
+            if (chr == Constants.COLON) {
+                colon = true;
+            } else {
+                trailingHeaders.append(chr);
+            }
+            pos++;
+        }
+        MessageBytes headerValue = headers.addValue(
+                trailingHeaders.getBytes(),
+                start, trailingHeaders.getEnd() - start);
+        // Mark the current buffer position
+        start = trailingHeaders.getEnd();
+        // Reading the header value (which can be spanned over
+        // multiple lines)
+        boolean eol = false;
+        boolean validLine = true;
+        int lastSignificantChar = 0;
+
+        while (validLine) {
+            boolean space = true;
+            // Skipping spaces
+            while (space) {
+                // Read new bytes if needed
+                if (pos >= lastValid) {
+                    if (readBytes() < 0)
+                        throw new EOFException(
+                            "Unexpected end of stream while reading " +
+                            "trailer headers for chunked request");
+                }
+                chr = buf[pos];
+                if (( chr == Constants.SP) || (chr == Constants.HT)) {
+                    pos++;
+                    // if we swallow whitespace, make sure it counts toward
+                    // the limit placed on trailing header size (if there
+                    // is one)
+                    if (trailingHeaders.getLimit() != -1) {
+                        int newlimit = trailingHeaders.getLimit() - 1;
+                        if (trailingHeaders.getEnd() > newlimit) {
+                            throw new IOException("Exceeded maxTrailerSize");
+                        }
+                        trailingHeaders.setLimit(newlimit);
+                    }
+                } else {
+                    space = false;
+                }
+            }
+
+            // Reading bytes until the end of the line
+            while (!eol) {
+                // Read new bytes if needed
+                if (pos >= lastValid) {
+                    if (readBytes() < 0)
+                        throw new EOFException(
+                            "Unexpected end of stream while reading trailer " +
+                            "headers for chunked request");
+                }
+                chr = buf[pos];
+                if (chr == Constants.CR || chr == Constants.LF) {
+                    parseCRLF(true);
+                    eol = true;
+                } else if (chr == Constants.SP) {
+                    trailingHeaders.append(chr);
+                } else {
+                    trailingHeaders.append(chr);
+                    lastSignificantChar = trailingHeaders.getEnd();
+                }
+
+                if (!eol) {
+                    pos++;
+                }
+            }
+
+            // Checking the first character of the new line. If the character
+            // is a LWS, the it's a multiline header
+            //
+            // Read new bytes if needed
+            if (pos >= lastValid) {
+                if (readBytes() < 0)
+                    throw new EOFException(
+                        "Unexpected end of stream while reading trailer " +
+                        "headers for chunked request");
+            }
+            chr = buf[pos];
+            if ((chr != Constants.SP) && (chr != Constants.HT)) {
+                validLine = false;
+            } else {
+                eol = false;
+                // Copying one extra space in the buffer (since there must
+                // be at lease one space inserted between the lines)
+                trailingHeaders.append(chr);
+            }
+        }
+
+        // Set the header value
+        headerValue.setBytes(trailingHeaders.getBytes(), start,
+                lastSignificantChar - start);
+
+        return true;
     }
 
 
+
+
+
 }
--- webapps/docs/changelog.xml.orig	2015-02-02 14:02:34.170831000 -0500
+++ webapps/docs/changelog.xml	2015-02-02 14:02:33.934831000 -0500
@@ -36,6 +36,11 @@
 <section name="Tomcat 6.0.24 (jfclere)">
   <subsection name="Catalina">
     <changelog>
+        <fix>
+            Add support for limiting the size of chunk extensions when 
+            using chunked encoding. (markt) CVE-2013-4322 patch applied by
+            Red Hat
+        </fix>
 	    <fix>
 		 	Remove unneeded handling of FORM authentication in RealmBase (kkolinko)
 			CVE-2012-3546 Patch backported to tc 6.0.24 by Red Hat
--- webapps/docs/config/systemprops.xml.orig	2015-02-02 14:02:33.663829000 -0500
+++ webapps/docs/config/systemprops.xml	2015-02-02 14:02:33.653832000 -0500
@@ -301,6 +301,22 @@
 
 <section name="Other">
 
+    <property name="org.apache.coyote.MAX_EXTENSION_SIZE">
+   <p>Limits the total length of extension data when using chunked encoding.
+   If the value is <code>-1</code>, no limit will be imposed.</p>
+   <p>If not specified, the default value of <code>8192</code> will be
+   used.</p>
+   </property>
+   
+   <property name="org.apache.coyote.MAX_TRAILER_SIZE">
+   <p>Limits the total length of trailing headers in the last chunk of
+   a chunked HTTP request.
+   If the value is <code>-1</code>, no limit will be imposed.</p>
+   <p>
+   If not specified, the default value of <code>8192</code> will be used.
+   </p>
+   </property>
+
   <properties>
 
     <property name="catalina.useNaming">
