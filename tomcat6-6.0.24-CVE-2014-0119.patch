--- java/org/apache/catalina/security/SecurityClassLoad.java.orig	2014-07-17 18:58:41.837253000 -0400
+++ java/org/apache/catalina/security/SecurityClassLoad.java	2014-07-17 19:01:24.805801000 -0400
@@ -25,7 +25,7 @@
  *
  * @author Glenn L. Nielsen
  * @author Jean-Francois Arcand
- * @version $Revision: 900131 $ $Date: 2010-01-17 13:46:53 +0100 (Sun, 17 Jan 2010) $
+ *
  */
 
 public final class SecurityClassLoad {
@@ -39,11 +39,12 @@
         
         loadCorePackage(loader);
         loadLoaderPackage(loader);
+        loadServletsPackage(loader);
         loadSessionPackage(loader);
         loadUtilPackage(loader);
         loadJavaxPackage(loader);
-        loadCoyotePackage(loader);        
-        loadHttp11Package(loader);        
+        loadCoyotePackage(loader);
+        loadHttp11Package(loader);
         loadTomcatPackage(loader);
     }
     
@@ -81,19 +82,24 @@
     }
     
     
+    private static final void loadServletsPackage(ClassLoader loader)
+            throws Exception {
+        final String basePackage = "org.apache.catalina.servlets.";
+        // Avoid a possible memory leak in the DefaultServlet when running with
+        // a security manager. The DefaultServlet needs to load an XML parser
+        // when running under a security manager. We want this to be loaded by
+        // the container rather than a web application to prevent a memory leak
+        // via web application class loader.
+        loader.loadClass(basePackage + "DefaultServlet");
+    }
+
+
     private final static void loadSessionPackage(ClassLoader loader)
         throws Exception {
-        String basePackage = "org.apache.catalina.";
-        loader.loadClass
-            (basePackage + "session.StandardSession");
-        loader.loadClass
-            (basePackage + "session.StandardSession$PrivilegedSetTccl");
-        loader.loadClass
-            (basePackage +
-             "session.StandardSession$1");
-        loader.loadClass
-            (basePackage +
-             "session.StandardManager$PrivilegedDoUnload");
+        String basePackage = "org.apache.catalina.session.";
+        loader.loadClass(basePackage + "StandardSession");
+        loader.loadClass(basePackage + "StandardSession$1");
+        loader.loadClass(basePackage + "StandardManager$PrivilegedDoUnload");
     }
     
     
@@ -119,9 +125,9 @@
     private final static void loadHttp11Package(ClassLoader loader)
         throws Exception {
         String basePackage = "org.apache.coyote.http11.";
-        loader.loadClass(basePackage + "Http11Processor$1");
         loader.loadClass(basePackage + "InternalOutputBuffer$1");
         loader.loadClass(basePackage + "InternalOutputBuffer$2");
+        loader.loadClass(basePackage + "Constants");
     }
     
     
@@ -212,6 +218,14 @@
         throws Exception {
         String basePackage = "org.apache.tomcat.";
         loader.loadClass(basePackage + "util.net.SSLSupport$CipherData");
+        // Make sure system property is read at this point
+        Class<?> clazz = loader.loadClass(
+                basePackage + "util.http.FastHttpDateFormat");
+        clazz.newInstance();
+
+        // security
+        loader.loadClass(basePackage + "util.security.PrivilegedGetTccl");
+        loader.loadClass(basePackage + "util.security.PrivilegedSetTccl");
     }
 }
 
--- java/org/apache/catalina/servlets/DefaultServlet.java.orig	2014-07-17 18:58:41.845254000 -0400
+++ java/org/apache/catalina/servlets/DefaultServlet.java	2014-07-17 19:03:20.702218000 -0400
@@ -14,8 +14,6 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
-
 package org.apache.catalina.servlets;
 
 
@@ -33,6 +31,7 @@
 import java.io.Reader;
 import java.io.StringReader;
 import java.io.StringWriter;
+import java.security.AccessController;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.Locale;
@@ -70,34 +69,68 @@
 import org.apache.naming.resources.ProxyDirContext;
 import org.apache.naming.resources.Resource;
 import org.apache.naming.resources.ResourceAttributes;
+import org.apache.tomcat.util.security.PrivilegedGetTccl;
+import org.apache.tomcat.util.security.PrivilegedSetTccl;
 import org.w3c.dom.Document;
 import org.xml.sax.InputSource;
 import org.xml.sax.SAXException;
 import org.xml.sax.ext.EntityResolver2;
- 
 
 
 /**
- * The default resource-serving servlet for most web applications,
+ * <p>The default resource-serving servlet for most web applications,
  * used to serve static resources such as HTML pages and images.
- *
+ * </p>
+ * <p>
+ * This servlet is intended to be mapped to <em>/</em> e.g.:
+ * </p>
+ * <pre>
+ *   &lt;servlet-mapping&gt;
+ *       &lt;servlet-name&gt;default&lt;/servlet-name&gt;
+ *       &lt;url-pattern&gt;/&lt;/url-pattern&gt;
+ *   &lt;/servlet-mapping&gt;
+ * </pre>
+ * <p>It can be mapped to sub-paths, however in all cases resources are served
+ * from the web appplication resource root using the full path from the root
+ * of the web application context.
+ * <br/>e.g. given a web application structure:
+ *</p>
+ * <pre>
+ * /context
+ *   /images
+ *     tomcat2.jpg
+ *   /static
+ *     /images
+ *       tomcat.jpg
+ * </pre>
+ * <p>
+ * ... and a servlet mapping that maps only <code>/static/*</code> to the default servlet:
+ * </p>
+ * <pre>
+ *   &lt;servlet-mapping&gt;
+ *       &lt;servlet-name&gt;default&lt;/servlet-name&gt;
+ *       &lt;url-pattern&gt;/static/*&lt;/url-pattern&gt;
+ *   &lt;/servlet-mapping&gt;
+ * </pre>
+ * <p>
+ * Then a request to <code>/context/static/images/tomcat.jpg</code> will succeed
+ * while a request to <code>/context/images/tomcat2.jpg</code> will fail.
+ * </p>
  * @author Craig R. McClanahan
  * @author Remy Maucherat
- * @version $Revision: 762909 $ $Date: 2009-04-07 21:12:35 +0200 (Tue, 07 Apr 2009) $
+ *
  */
 
 public class DefaultServlet
     extends HttpServlet {
-    
+
     private static final DocumentBuilderFactory factory;
 
-    private static final SecureEntityResolver secureEntityResolver =
-            new SecureEntityResolver();
+    private static final SecureEntityResolver secureEntityResolver;
 
 
     // ----------------------------------------------------- Instance Variables
 
-
     /**
      * The debugging detail level for this servlet.
      */
@@ -137,13 +170,19 @@
     /**
      * Allow customized directory listing per directory.
      */
-    protected String  localXsltFile = null;
+    protected String localXsltFile = null;
+
+
+    /**
+     * Allow customized directory listing per context.
+     */
+    protected String contextXsltFile = null;
 
 
     /**
      * Allow customized directory listing per instance.
      */
-    protected String  globalXsltFile = null;
+    protected String globalXsltFile = null;
 
 
     /**
@@ -163,13 +202,13 @@
      * the platform default is used.
      */
     protected String fileEncoding = null;
-    
-    
+
+
     /**
      * Minimum size for sendfile usage in bytes.
      */
     protected int sendfileSize = 48 * 1024;
-    
+
     /**
      * Should the Accept-Ranges: bytes header be send with static resources?
      */
@@ -179,8 +218,8 @@
      * Full range marker.
      */
     protected static ArrayList FULL = new ArrayList();
-    
-    
+
+
     // ----------------------------------------------------- Static Initializer
 
 
@@ -195,9 +234,15 @@
         urlEncoder.addSafeCharacter('*');
         urlEncoder.addSafeCharacter('/');
 
-        factory = DocumentBuilderFactory.newInstance();
-        factory.setNamespaceAware(true);
-        factory.setValidating(false);
+        if (Globals.IS_SECURITY_ENABLED) {
+            factory = DocumentBuilderFactory.newInstance();
+            factory.setNamespaceAware(true);
+            factory.setValidating(false);
+            secureEntityResolver = new SecureEntityResolver();
+        } else {
+            factory = null;
+            secureEntityResolver = null;
+        }
     }
 
 
@@ -256,12 +301,13 @@
             readOnly = Boolean.parseBoolean(getServletConfig().getInitParameter("readonly"));
 
         if (getServletConfig().getInitParameter("sendfileSize") != null)
-            sendfileSize = 
+            sendfileSize =
                 Integer.parseInt(getServletConfig().getInitParameter("sendfileSize")) * 1024;
 
         fileEncoding = getServletConfig().getInitParameter("fileEncoding");
 
         globalXsltFile = getServletConfig().getInitParameter("globalXsltFile");
+        contextXsltFile = getServletConfig().getInitParameter("contextXsltFile");
         localXsltFile = getServletConfig().getInitParameter("localXsltFile");
         readmeFile = getServletConfig().getInitParameter("readmeFile");
 
@@ -309,16 +355,26 @@
      * @param request The servlet request we are processing
      */
     protected String getRelativePath(HttpServletRequest request) {
+        // IMPORTANT: DefaultServlet can be mapped to '/' or '/path/*' but always
+        // serves resources from the web app root with context rooted paths.
+        // i.e. it can not be used to mount the web app root under a sub-path
+        // This method must construct a complete context rooted path, although
+        // subclasses can change this behaviour.
 
         // Are we being processed by a RequestDispatcher.include()?
         if (request.getAttribute(Globals.INCLUDE_REQUEST_URI_ATTR) != null) {
             String result = (String) request.getAttribute(
                                             Globals.INCLUDE_PATH_INFO_ATTR);
-            if (result == null)
+            if (result == null) {
                 result = (String) request.getAttribute(
                                             Globals.INCLUDE_SERVLET_PATH_ATTR);
-            if ((result == null) || (result.equals("")))
+            } else {
+                result = (String) request.getAttribute(
+                                  Globals.INCLUDE_SERVLET_PATH_ATTR) + result;
+            }
+            if ((result == null) || (result.equals(""))) {
                 result = "/";
+            }
             return (result);
         }
 
@@ -326,6 +382,8 @@
         String result = request.getPathInfo();
         if (result == null) {
             result = request.getServletPath();
+        } else {
+            result = request.getServletPath() + result;
         }
         if ((result == null) || (result.equals(""))) {
             result = "/";
@@ -336,6 +394,18 @@
 
 
     /**
+     * Determines the appropriate path to prepend resources with
+     * when generating directory listings. Depending on the behaviour of
+     * {@link #getRelativePath(HttpServletRequest)} this will change.
+     * @param request the request to determine the path for
+     * @return the prefix to apply to all resources in the listing.
+     */
+    protected String getPathPrefix(final HttpServletRequest request) {
+        return request.getContextPath();
+    }
+
+
+    /**
      * Process a GET request for the specified resource.
      *
      * @param request The servlet request we are processing
@@ -383,7 +453,7 @@
      *
      * @param resp  the {@link HttpServletResponse} object that
      *                  contains the response the servlet returns
-     *                  to the client                                
+     *                  to the client
      *
      * @exception IOException   if an input or output error occurs
      *                              while the servlet is handling the
@@ -395,7 +465,7 @@
     protected void doOptions(HttpServletRequest req, HttpServletResponse resp)
         throws ServletException, IOException {
 
-        StringBuffer allow = new StringBuffer();
+        StringBuilder allow = new StringBuilder();
         // There is a doGet method
         allow.append("GET, HEAD");
         // There is a doPost
@@ -411,11 +481,11 @@
         }
         // Always allow options
         allow.append(", OPTIONS");
-        
+
         resp.setHeader("Allow", allow.toString());
     }
-    
-    
+
+
     /**
      * Process a POST request for the specified resource.
      *
@@ -695,7 +765,7 @@
         CacheEntry cacheEntry = resources.lookupCache(path);
 
         if (!cacheEntry.exists) {
-            // Check if we're included so we can return the appropriate 
+            // Check if we're included so we can return the appropriate
             // missing resource name in the error
             String requestUri = (String) request.getAttribute(
                                             Globals.INCLUDE_REQUEST_URI_ATTR);
@@ -720,7 +790,7 @@
         // ends with "/" or "\", return NOT FOUND
         if (cacheEntry.context == null) {
             if (path.endsWith("/") || (path.endsWith("\\"))) {
-                // Check if we're included so we can return the appropriate 
+                // Check if we're included so we can return the appropriate
                 // missing resource name in the error
                 String requestUri = (String) request.getAttribute(
                                             Globals.INCLUDE_REQUEST_URI_ATTR);
@@ -733,6 +803,13 @@
             }
         }
 
+        boolean isError = false;
+        Integer status =
+            (Integer) request.getAttribute("javax.servlet.error.status_code");
+        if (status != null) {
+            isError = status.intValue() >= HttpServletResponse.SC_BAD_REQUEST;
+        }
+
         // Check if the conditions specified in the optional If headers are
         // satisfied.
         if (cacheEntry.context == null) {
@@ -740,8 +817,8 @@
             // Checking If headers
             boolean included =
                 (request.getAttribute(Globals.INCLUDE_CONTEXT_PATH_ATTR) != null);
-            if (!included
-                && !checkIfHeaders(request, response, cacheEntry.attributes)) {
+            if (!included && !isError &&
+                    !checkIfHeaders(request, response, cacheEntry.attributes)) {
                 return;
             }
 
@@ -769,20 +846,22 @@
             contentType = "text/html;charset=UTF-8";
 
         } else {
-            if (useAcceptRanges) {
-                // Accept ranges header
-                response.setHeader("Accept-Ranges", "bytes");
-            }
+            if (!isError) {
+                if (useAcceptRanges) {
+                    // Accept ranges header
+                    response.setHeader("Accept-Ranges", "bytes");
+                }
 
-            // Parse range specifier
-            ranges = parseRange(request, response, cacheEntry.attributes);
+                // Parse range specifier
+                ranges = parseRange(request, response, cacheEntry.attributes);
 
-            // ETag header
-            response.setHeader("ETag", cacheEntry.attributes.getETag());
+                // ETag header
+                response.setHeader("ETag", cacheEntry.attributes.getETag());
 
-            // Last-Modified header
-            response.setHeader("Last-Modified",
-                    cacheEntry.attributes.getLastModifiedHttp());
+                // Last-Modified header
+                response.setHeader("Last-Modified",
+                        cacheEntry.attributes.getLastModifiedHttp());
+            }
 
             // Get content length
             contentLength = cacheEntry.attributes.getContentLength();
@@ -817,7 +896,8 @@
 
         }
 
-        if ( (cacheEntry.context != null) 
+        if ( (cacheEntry.context != null)
+                || isError
                 || ( ((ranges == null) || (ranges.isEmpty()))
                         && (request.getHeader("Range") == null) )
                 || (ranges == FULL) ) {
@@ -846,8 +926,7 @@
 
                 if (content) {
                     // Serve the directory browser
-                    renderResult =
-                        render(request.getContextPath(), cacheEntry);
+                    renderResult = render(getPathPrefix(request), cacheEntry);
                 }
 
             }
@@ -1139,7 +1218,6 @@
     }
 
 
-
     /**
      *  Decide which way to render. HTML or XML.
      */
@@ -1148,13 +1226,14 @@
 
         Source xsltSource = findXsltInputStream(cacheEntry.context);
 
-        if (xsltSource==null) {
+        if (xsltSource == null) {
             return renderHtml(contextPath, cacheEntry);
         }
-
         return renderXml(contextPath, cacheEntry, xsltSource);
+
     }
 
+
     /**
      * Return an InputStream to an HTML representation of the contents
      * of this directory.
@@ -1167,7 +1246,7 @@
                                     Source xsltSource)
         throws IOException, ServletException {
 
-        StringBuffer sb = new StringBuffer();
+        StringBuilder sb = new StringBuilder();
 
         sb.append("<?xml version=\"1.0\"?>");
         sb.append("<listing ");
@@ -1186,7 +1265,7 @@
 
             // Render the directory entries within this directory
             NamingEnumeration enumeration = resources.list(cacheEntry.name);
-            
+
             // rewriteUrl(contextPath) is expensive. cache result for later reuse
             String rewrittenContextPath =  rewriteUrl(contextPath);
 
@@ -1200,6 +1279,9 @@
                     trimmed.equalsIgnoreCase(localXsltFile))
                     continue;
 
+                if ((cacheEntry.name + trimmed).equals(contextXsltFile))
+                    continue;
+
                 CacheEntry childCacheEntry =
                     resources.lookupCache(cacheEntry.name + resourceName);
                 if (!childCacheEntry.exists) {
@@ -1247,14 +1329,29 @@
             sb.append("]]></readme>");
         }
 
-
         sb.append("</listing>");
 
-
+        // Prevent possible memory leak. Ensure Transformer and
+        // TransformerFactory are not loaded from the web application.
+        ClassLoader original;
+        if (Globals.IS_SECURITY_ENABLED) {
+            PrivilegedGetTccl pa = new PrivilegedGetTccl();
+            original = AccessController.doPrivileged(pa);
+        } else {
+            original = Thread.currentThread().getContextClassLoader();
+        }
         try {
+            if (Globals.IS_SECURITY_ENABLED) {
+                PrivilegedSetTccl pa =
+                        new PrivilegedSetTccl(DefaultServlet.class.getClassLoader());
+                AccessController.doPrivileged(pa);
+            } else {
+                Thread.currentThread().setContextClassLoader(
+                        DefaultServlet.class.getClassLoader());
+            }
+
             TransformerFactory tFactory = TransformerFactory.newInstance();
-            Source xmlSource = 
-                new StreamSource(new StringReader(sb.toString()));
+            Source xmlSource = new StreamSource(new StringReader(sb.toString()));
             Transformer transformer = tFactory.newTransformer(xsltSource);
 
             ByteArrayOutputStream stream = new ByteArrayOutputStream();
@@ -1265,6 +1362,13 @@
             return (new ByteArrayInputStream(stream.toByteArray()));
         } catch (TransformerException e) {
             throw new ServletException("XSL transformer error", e);
+        } finally {
+            if (Globals.IS_SECURITY_ENABLED) {
+                PrivilegedSetTccl pa = new PrivilegedSetTccl(original);
+                AccessController.doPrivileged(pa);
+            } else {
+                Thread.currentThread().setContextClassLoader(original);
+            }
         }
     }
 
@@ -1292,8 +1396,8 @@
         OutputStreamWriter osWriter = new OutputStreamWriter(stream, "UTF8");
         PrintWriter writer = new PrintWriter(osWriter);
 
-        StringBuffer sb = new StringBuffer();
-        
+        StringBuilder sb = new StringBuilder();
+
         // rewriteUrl(contextPath) is expensive. cache result for later reuse
         String rewrittenContextPath =  rewriteUrl(contextPath);
 
@@ -1480,7 +1584,7 @@
 
 
     /**
-     * Return the xsl template inputstream (if possible)
+     * Return a Source for the xsl template (if possible)
      */
     protected Source findXsltInputStream(DirContext directory)
         throws IOException, ServletException {
@@ -1501,18 +1605,30 @@
             } catch (NamingException e) {
                 if (debug > 10)
                     log("localXsltFile '" + localXsltFile + "' not found", e);
+            }
+        }
 
-                return null;
+        if (contextXsltFile != null) {
+            InputStream is =
+                getServletContext().getResourceAsStream(contextXsltFile);
+            if (is != null) {
+                if (Globals.IS_SECURITY_ENABLED) {
+                    return secureXslt(is);
+                } else {
+                    return new StreamSource(is);
+                }
             }
-       }
+
+            if (debug > 10)
+                log("contextXsltFile '" + contextXsltFile + "' not found");
+        }
 
         /*  Open and read in file in one fell swoop to reduce chance
          *  chance of leaving handle open.
          */
-        if (globalXsltFile!=null) {
+        if (globalXsltFile != null) {
             File f = validateGlobalXsltFile();
-            if ( f != null) {
-            
+            if (f != null){
                 FileInputStream fis = null;
                 try {
                     fis = new FileInputStream(f);
@@ -1520,7 +1636,7 @@
                     fis.read(b);
                     return new StreamSource(new ByteArrayInputStream(b));
                 } finally {
-                    if (fis!=null) {
+                    if (fis != null) {
                         try {
                             fis.close();
                         } catch (IOException ioe) {
@@ -1534,8 +1650,10 @@
         }
 
         return null;
+
     }
 
+
     private File validateGlobalXsltFile() {
 
         File result = null;
@@ -1622,15 +1740,8 @@
     }
 
 
-
-
-
-
-
-
     // -------------------------------------------------------- protected Methods
 
-
     /**
      * Check if sendfile can be used.
      */
@@ -1658,14 +1769,14 @@
             return false;
         }
     }
-    
-    
+
+
     /**
      * Check if the if-match condition is satisfied.
      *
      * @param request The servlet request we are processing
      * @param response The servlet response we are creating
-     * @param resourceInfo File object
+     * @param resourceAttributes Attributes of requested resource
      * @return boolean true if the resource meets the specified condition,
      * and false if the condition is not satisfied, in which case request
      * processing is stopped
@@ -1710,7 +1821,7 @@
      *
      * @param request The servlet request we are processing
      * @param response The servlet response we are creating
-     * @param resourceInfo File object
+     * @param resourceAttributes Attributes of requested resource
      * @return boolean true if the resource meets the specified condition,
      * and false if the condition is not satisfied, in which case request
      * processing is stopped
@@ -1749,7 +1860,7 @@
      *
      * @param request The servlet request we are processing
      * @param response The servlet response we are creating
-     * @param resourceInfo File object
+     * @param resourceAttributes Attributes of requested resource
      * @return boolean true if the resource meets the specified condition,
      * and false if the condition is not satisfied, in which case request
      * processing is stopped
@@ -1809,7 +1920,7 @@
      *
      * @param request The servlet request we are processing
      * @param response The servlet response we are creating
-     * @param resourceInfo File object
+     * @param resourceAttributes Attributes of requested resource
      * @return boolean true if the resource meets the specified condition,
      * and false if the condition is not satisfied, in which case request
      * processing is stopped
@@ -1842,7 +1953,7 @@
      * output stream, and ensure that both streams are closed before returning
      * (even in the face of an exception).
      *
-     * @param resourceInfo The resource information
+     * @param cacheEntry Cached version of requested resource
      * @param ostream The output stream to write to
      *
      * @exception IOException if an input/output error occurs
@@ -1888,7 +1999,7 @@
      * output stream, and ensure that both streams are closed before returning
      * (even in the face of an exception).
      *
-     * @param resourceInfo The resource info
+     * @param cacheEntry Cached version of requested resource
      * @param writer The writer to write to
      *
      * @exception IOException if an input/output error occurs
@@ -1931,7 +2042,7 @@
      * output stream, and ensure that both streams are closed before returning
      * (even in the face of an exception).
      *
-     * @param resourceInfo The ResourceInfo object
+     * @param cacheEntry Cached version of requested resource
      * @param ostream The output stream to write to
      * @param range Range the client wanted to retrieve
      * @exception IOException if an input/output error occurs
@@ -1962,7 +2073,7 @@
      * output stream, and ensure that both streams are closed before returning
      * (even in the face of an exception).
      *
-     * @param resourceInfo The ResourceInfo object
+     * @param cacheEntry Cached version of requested resource
      * @param writer The writer to write to
      * @param range Range the client wanted to retrieve
      * @exception IOException if an input/output error occurs
@@ -2000,7 +2111,7 @@
      * output stream, and ensure that both streams are closed before returning
      * (even in the face of an exception).
      *
-     * @param resourceInfo The ResourceInfo object
+     * @param cacheEntry Cached version of requested resource
      * @param ostream The output stream to write to
      * @param ranges Enumeration of the ranges the client wanted to retrieve
      * @param contentType Content type of the resource
@@ -2053,7 +2164,7 @@
      * output stream, and ensure that both streams are closed before returning
      * (even in the face of an exception).
      *
-     * @param resourceInfo The ResourceInfo object
+     * @param cacheEntry Cached version of requested resource
      * @param writer The writer to write to
      * @param ranges Enumeration of the ranges the client wanted to retrieve
      * @param contentType Content type of the resource
@@ -2068,7 +2179,7 @@
         while ( (exception == null) && (ranges.hasNext()) ) {
 
             InputStream resourceInputStream = cacheEntry.resource.streamContent();
-            
+
             Reader reader;
             if (fileEncoding == null) {
                 reader = new InputStreamReader(resourceInputStream);
@@ -2296,12 +2407,12 @@
 
     }
 
+
     /**
-     * This is secure in the sense that any attempt to use an external
-     * entity
+     * This is secure in the sense that any attempt to use an external entity
      * will trigger an exception.
      */
-   private static class SecureEntityResolver implements EntityResolver2  {
+    private static class SecureEntityResolver implements EntityResolver2  {
 
         public InputSource resolveEntity(String publicId, String systemId)
                 throws SAXException, IOException {
--- java/org/apache/catalina/session/StandardSession.java.orig	2014-07-17 20:06:15.782991000 -0400
+++ java/org/apache/catalina/session/StandardSession.java	2014-07-17 20:01:12.241918000 -0400
@@ -59,6 +59,8 @@
 import org.apache.catalina.core.StandardContext;
 import org.apache.catalina.realm.GenericPrincipal;
 import org.apache.catalina.security.SecurityUtil;
+import org.apache.catalina.session.ManagerBase.SessionTiming;
+import org.apache.tomcat.util.security.PrivilegedSetTccl;
 
 /**
  * Standard implementation of the <b>Session</b> interface.  This object is
@@ -78,7 +80,7 @@
  * @author Craig R. McClanahan
  * @author Sean Legassick
  * @author <a href="mailto:jon@latchkey.com">Jon S. Stevens</a>
- * @version $Revision: 900131 $ $Date: 2010-01-17 13:46:53 +0100 (Sun, 17 Jan 2010) $
+ *
  */
 
 public class StandardSession
@@ -341,6 +343,14 @@
      * @param id The new session identifier
      */
     public void setId(String id) {
+        setId(id, true);
+    }
+
+
+    /**
+     * {@inheritDoc}
+     */
+    public void setId(String id, boolean notify) {
 
         if ((this.id != null) && (manager != null))
             manager.remove(this);
@@ -349,7 +359,10 @@
 
         if (manager != null)
             manager.add(this);
-        tellNew();
+        
+        if (notify) {
+            tellNew();
+        }
     }
 
 
@@ -750,13 +763,27 @@
                     manager.setSessionMaxAliveTime(timeAlive);
                 }
                 int numExpired = manager.getExpiredSessions();
-                numExpired++;
-                manager.setExpiredSessions(numExpired);
+                if (numExpired < Integer.MAX_VALUE) {
+                    numExpired++;
+                    manager.setExpiredSessions(numExpired);
+                }
+
                 int average = manager.getSessionAverageAliveTime();
-                average = ((average * (numExpired-1)) + timeAlive)/numExpired;
+                // Using long, as otherwise (average * numExpired) might overflow 
+                average = (int) (((((long) average) * (numExpired - 1)) + timeAlive)
+                        / numExpired);
                 manager.setSessionAverageAliveTime(average);
             }
 
+            if (manager instanceof ManagerBase) {
+                ManagerBase mb = (ManagerBase) manager;
+                SessionTiming timing = new SessionTiming(timeNow, timeAlive);
+                synchronized (mb.sessionExpirationTiming) {
+                    mb.sessionExpirationTiming.add(timing);
+                    mb.sessionExpirationTiming.poll();
+                }
+            }
+
             // Remove this session from our manager's active sessions
             manager.remove(this);
 
@@ -1321,7 +1348,7 @@
             throw new IllegalStateException
                 (sm.getString("standardSession.setAttribute.ise"));
         if ((manager != null) && manager.getDistributable() &&
-          !(value instanceof Serializable))
+          !isAttributeDistributable(name, value))
             throw new IllegalArgumentException
                 (sm.getString("standardSession.setAttribute.iae", name));
         // Construct an event with the new value
@@ -1428,6 +1455,19 @@
         return (this.isValid || this.expiring);
     }
 
+    /**
+     * Check whether the Object can be distributed. This implementation
+     * simply checks for serializability. Derived classes might use other
+     * distribution technology not based on serialization and can extend
+     * this check.
+     * @param name The name of the attribute to check
+     * @param value The value of the attribute to check
+     * @return true if the attribute is distributable, false otherwise
+     */
+    protected boolean isAttributeDistributable(String name, Object value) {
+        return value instanceof Serializable;
+    }
+
 
     /**
      * Read a serialized version of this session object from the specified
@@ -1564,7 +1604,7 @@
 
 
     /**
-     * Exclude attribute that cannot be serialized.
+     * Exclude standard attributes that cannot be serialized.
      * @param name the attribute's name
      */
     protected boolean exclude(String name){
@@ -1705,28 +1745,9 @@
                     (sm.getString("standardSession.attributeEvent"), t);
             }
         }
-
-    }
-
-
-    private static class PrivilegedSetTccl
-    implements PrivilegedAction<Void> {
-
-        private ClassLoader cl;
-
-        PrivilegedSetTccl(ClassLoader cl) {
-            this.cl = cl;
-        }
-
-        public Void run() {
-            Thread.currentThread().setContextClassLoader(cl);
-            return null;
-        }
     }
-
 }
 
-
 // ------------------------------------------------------------ Protected Class
 
 
--- java/org/apache/jasper/compiler/ELFunctionMapper.java.orig	2014-07-17 18:58:41.860251000 -0400
+++ java/org/apache/jasper/compiler/ELFunctionMapper.java	2014-07-17 19:05:49.519704000 -0400
@@ -17,9 +17,14 @@
 
 package org.apache.jasper.compiler;
 
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 import java.util.*;
 import javax.servlet.jsp.tagext.FunctionInfo;
+
+import org.apache.jasper.Constants;
 import org.apache.jasper.JasperException;
+import org.apache.tomcat.util.security.PrivilegedGetTccl;
 
 /**
  * This class generates functions mappers for the EL expressions in the page.
@@ -202,8 +207,8 @@
                 FunctionInfo funcInfo = f.getFunctionInfo();
                 String key = f.getPrefix()+ ":" + f.getName();
                 ds.append(funcMethod + "(\"" + key + "\", " +
-                        funcInfo.getFunctionClass() + ".class, " +
-                        '\"' + f.getMethodName() + "\", " +
+                        getCanonicalName(funcInfo.getFunctionClass()) +
+                        ".class, " + '\"' + f.getMethodName() + "\", " +
                         "new Class[] {");
                 String params[] = f.getParameters();
                 for (int k = 0; k < params.length; k++) {
@@ -276,6 +281,32 @@
         private String getMapName() {
             return "_jspx_fnmap_" + currFunc++;
         }
+
+        /**
+         * Convert a binary class name into a canonical one that can be used
+         * when generating Java source code.
+         * 
+         * @param className Binary class name
+         * @return          Canonical equivalent
+         */
+        private String getCanonicalName(String className) throws JasperException {
+            Class<?> clazz;
+            
+            ClassLoader tccl;
+            if (Constants.IS_SECURITY_ENABLED) {
+                PrivilegedAction<ClassLoader> pa = new PrivilegedGetTccl();
+                tccl = AccessController.doPrivileged(pa);
+            } else {
+                tccl = Thread.currentThread().getContextClassLoader();
+            }
+
+            try {
+                clazz = Class.forName(className, false, tccl);
+            } catch (ClassNotFoundException e) {
+                throw new JasperException(e);
+            }
+            return clazz.getCanonicalName();
+        }
     }
 }
 
--- java/org/apache/jasper/compiler/JspDocumentParser.java.orig	2014-07-17 18:58:41.867251000 -0400
+++ java/org/apache/jasper/compiler/JspDocumentParser.java	2014-07-17 19:06:43.497878000 -0400
@@ -20,7 +20,7 @@
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
-
+import java.security.AccessController;
 import java.util.Iterator;
 import java.util.List;
 import java.util.jar.JarFile;
@@ -36,6 +36,8 @@
 import org.apache.jasper.JspCompilationContext;
 import org.apache.tomcat.util.descriptor.DigesterFactory;
 import org.apache.tomcat.util.descriptor.LocalResolver;
+import org.apache.tomcat.util.security.PrivilegedGetTccl;
+import org.apache.tomcat.util.security.PrivilegedSetTccl;
 import org.xml.sax.Attributes;
 import org.xml.sax.InputSource;
 import org.xml.sax.Locator;
@@ -131,7 +133,7 @@
                 Constants.XML_BLOCK_EXTERNAL_INIT_PARAM);
         boolean blockExternal;
         if (blockExternalString == null) {
-            blockExternal = Constants.IS_SECURITY_ENABLED;
+            blockExternal = true;
         } else {
             blockExternal = Boolean.parseBoolean(blockExternalString);
         }
@@ -1454,33 +1456,58 @@
         JspDocumentParser jspDocParser)
         throws Exception {
 
-        SAXParserFactory factory = SAXParserFactory.newInstance();
-
-        factory.setNamespaceAware(true);
-        // Preserve xmlns attributes
-        factory.setFeature(
-            "http://xml.org/sax/features/namespace-prefixes",
-            true);
-
-        factory.setValidating(validating);
-        if (validating) {
-            // Enable DTD validation
-            factory.setFeature(
-                    "http://xml.org/sax/features/validation",
-                    true);
-            // Enable schema validation
-            factory.setFeature(
-                    "http://apache.org/xml/features/validation/schema",
-                    true);
+        ClassLoader original;
+        if (Constants.IS_SECURITY_ENABLED) {
+            PrivilegedGetTccl pa = new PrivilegedGetTccl();
+            original = AccessController.doPrivileged(pa);
+        } else {
+            original = Thread.currentThread().getContextClassLoader();
         }
+        try {
+            if (Constants.IS_SECURITY_ENABLED) {
+                PrivilegedSetTccl pa =
+                        new PrivilegedSetTccl(JspDocumentParser.class.getClassLoader());
+                AccessController.doPrivileged(pa);
+            } else {
+                Thread.currentThread().setContextClassLoader(
+                        JspDocumentParser.class.getClassLoader());
+            }
+
+            SAXParserFactory factory = SAXParserFactory.newInstance();
 
-        // Configure the parser
-        SAXParser saxParser = factory.newSAXParser();
-        XMLReader xmlReader = saxParser.getXMLReader();
-        xmlReader.setProperty(LEXICAL_HANDLER_PROPERTY, jspDocParser);
-        xmlReader.setErrorHandler(jspDocParser);
+            factory.setNamespaceAware(true);
+            // Preserve xmlns attributes
+            factory.setFeature(
+                "http://xml.org/sax/features/namespace-prefixes",
+                true);
 
-        return saxParser;
+            factory.setValidating(validating);
+            if (validating) {
+                // Enable DTD validation
+                factory.setFeature(
+                        "http://xml.org/sax/features/validation",
+                        true);
+                // Enable schema validation
+                factory.setFeature(
+                        "http://apache.org/xml/features/validation/schema",
+                        true);
+            }
+
+            // Configure the parser
+            SAXParser saxParser = factory.newSAXParser();
+            XMLReader xmlReader = saxParser.getXMLReader();
+            xmlReader.setProperty(LEXICAL_HANDLER_PROPERTY, jspDocParser);
+            xmlReader.setErrorHandler(jspDocParser);
+
+            return saxParser;
+        } finally {
+            if (Constants.IS_SECURITY_ENABLED) {
+                PrivilegedSetTccl pa = new PrivilegedSetTccl(original);
+                AccessController.doPrivileged(pa);
+            } else {
+                Thread.currentThread().setContextClassLoader(original);
+            }
+        }
     }
 
     /*
--- java/org/apache/jasper/xmlparser/ParserUtils.java.orig	2014-07-21 13:48:23.555747000 -0400
+++ java/org/apache/jasper/xmlparser/ParserUtils.java	2014-07-17 19:09:10.844373000 -0400
@@ -18,6 +18,7 @@
 
 import java.io.IOException;
 import java.io.InputStream;
+import java.security.AccessController;
 
 import javax.xml.parsers.DocumentBuilder;
 import javax.xml.parsers.DocumentBuilderFactory;
@@ -29,6 +30,8 @@
 import org.apache.tomcat.util.descriptor.DigesterFactory;
 import org.apache.tomcat.util.descriptor.LocalResolver;
 import org.apache.tomcat.util.descriptor.XmlErrorHandler;
+import org.apache.tomcat.util.security.PrivilegedGetTccl;
+import org.apache.tomcat.util.security.PrivilegedSetTccl;
 import org.w3c.dom.Comment;
 import org.w3c.dom.Document;
 import org.w3c.dom.NamedNodeMap;
@@ -47,7 +50,7 @@
  * use a separate class loader for the parser to be used.
  *
  * @author Craig R. McClanahan
- * @version $Id: ParserUtils.java 1558828 2014-01-16 15:12:59Z markt $
+ *
  */
 public class ParserUtils {
 
@@ -105,7 +108,23 @@
         Document document = null;
 
         // Perform an XML parse of this document, via JAXP
+        ClassLoader original;
+        if (Constants.IS_SECURITY_ENABLED) {
+            PrivilegedGetTccl pa = new PrivilegedGetTccl();
+            original = AccessController.doPrivileged(pa);
+        } else {
+            original = Thread.currentThread().getContextClassLoader();
+        }
         try {
+            if (Constants.IS_SECURITY_ENABLED) {
+                PrivilegedSetTccl pa =
+                        new PrivilegedSetTccl(ParserUtils.class.getClassLoader());
+                AccessController.doPrivileged(pa);
+            } else {
+                Thread.currentThread().setContextClassLoader(
+                        ParserUtils.class.getClassLoader());
+            }
+            
             DocumentBuilderFactory factory =
                 DocumentBuilderFactory.newInstance();
             factory.setNamespaceAware(true);
@@ -129,23 +148,30 @@
                 // throw the first to indicate there was a error during processing
                 throw handler.getErrors().iterator().next();
             }
-	} catch (ParserConfigurationException ex) {
-            throw new JasperException
-                (Localizer.getMessage("jsp.error.parse.xml", location), ex);
-	} catch (SAXParseException ex) {
-            throw new JasperException
-                (Localizer.getMessage("jsp.error.parse.xml.line",
-                      location,
-				      Integer.toString(ex.getLineNumber()),
-				      Integer.toString(ex.getColumnNumber())),
-		 ex);
-	} catch (SAXException sx) {
-            throw new JasperException
-                (Localizer.getMessage("jsp.error.parse.xml", location), sx);
+        } catch (ParserConfigurationException ex) {
+            throw new JasperException(
+                    Localizer.getMessage("jsp.error.parse.xml", location), ex);
+        } catch (SAXParseException ex) {
+            throw new JasperException(
+                    Localizer.getMessage("jsp.error.parse.xml.line",
+                            location,
+                            Integer.toString(ex.getLineNumber()),
+        			        Integer.toString(ex.getColumnNumber())),
+			        ex);
+        } catch (SAXException sx) {
+            throw new JasperException(
+                    Localizer.getMessage("jsp.error.parse.xml", location), sx);
         } catch (IOException io) {
-            throw new JasperException
-                (Localizer.getMessage("jsp.error.parse.xml", location), io);
-	}
+            throw new JasperException(
+                    Localizer.getMessage("jsp.error.parse.xml", location), io);
+        } finally {
+            if (Constants.IS_SECURITY_ENABLED) {
+                PrivilegedSetTccl pa = new PrivilegedSetTccl(original);
+                AccessController.doPrivileged(pa);
+            } else {
+                Thread.currentThread().setContextClassLoader(original);
+            }
+        }
 
         // Convert the resulting document to a graph of TreeNodes
         return (convert(null, document.getDocumentElement()));
@@ -226,6 +252,7 @@
                 }
             }
         }
+
         // Return the completed TreeNode graph
         return (treeNode);
     }
--- java/org/apache/catalina/startup/TldConfig.java.orig	2014-07-17 19:13:44.148293000 -0400
+++ java/org/apache/catalina/startup/TldConfig.java	2014-07-18 16:50:12.278698000 -0400
@@ -94,6 +94,8 @@
         noTldJars.add("ecj-4.2.1.jar");
         noTldJars.add("ecj-4.2.2.jar");
         noTldJars.add("ecj-4.3.1.jar");
+        noTldJars.add("ecj-4.3.2.jar");
+        noTldJars.add("ecj-P20140317-1600.jar");
         noTldJars.add("jsp-api.jar");
         noTldJars.add("servlet-api.jar");
         noTldJars.add("tomcat-coyote.jar");
@@ -136,30 +138,29 @@
     /**
      * The <code>Digester</code>s available to process tld files.
      */
-    private static Digester[] tldDigesters = new Digester[2];
+    private static Digester[] tldDigesters = new Digester[4];
 
     /**
      * Create (if necessary) and return a Digester configured to process the
      * tld.
      */
-    private static Digester createTldDigester(boolean validation,
+    private static synchronized Digester createTldDigester(boolean validation,
             boolean blockExternal) {
 
-        Digester digester = null;
-        if (!validation) {
-            if (tldDigesters[0] == null) {
-                tldDigesters[0] = DigesterFactory.newDigester(validation,
-                        true, new TldRuleSet(), blockExternal);
-                tldDigesters[0].getParser();
-            }
-            digester = tldDigesters[0];
-        } else {
-            if (tldDigesters[1] == null) {
-                tldDigesters[1] = DigesterFactory.newDigester(validation,
-                        true, new TldRuleSet(), blockExternal);
-                tldDigesters[1].getParser();
-            }
-            digester = tldDigesters[1];
+        Digester digester;
+        int cacheIndex = 0;
+        if (validation) {
+            cacheIndex += 1;
+        }
+        if (blockExternal) {
+            cacheIndex += 2;
+        }
+        digester = tldDigesters[cacheIndex];
+        if (digester == null) {
+            digester = DigesterFactory.newDigester(validation,
+                    true, new TldRuleSet(), blockExternal);
+            digester.getParser();
+            tldDigesters[cacheIndex] = digester;
         }
         return digester;
     }
--- java/org/apache/catalina/session/ManagerBase.java.orig	2014-07-17 20:09:39.433687000 -0400
+++ java/org/apache/catalina/session/ManagerBase.java	2014-07-17 20:11:41.772058000 -0400
@@ -25,15 +25,19 @@
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.IOException;
+import java.io.UnsupportedEncodingException;
 import java.lang.reflect.Method;
 import java.security.AccessController;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import java.security.PrivilegedAction;
+import java.util.ArrayList;
 import java.util.Date;
 import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
 import java.util.Map;
 import java.util.Random;
 import java.util.concurrent.ConcurrentHashMap;
@@ -43,10 +47,12 @@
 import javax.management.ObjectName;
 
 import org.apache.catalina.Container;
+import org.apache.catalina.Context;
 import org.apache.catalina.Engine;
 import org.apache.catalina.Globals;
 import org.apache.catalina.Manager;
 import org.apache.catalina.Session;
+import org.apache.catalina.core.ContainerBase;
 import org.apache.catalina.core.StandardContext;
 import org.apache.catalina.core.StandardHost;
 import org.apache.catalina.util.StringManager;
@@ -61,7 +67,7 @@
  * be subclassed to create more sophisticated Manager implementations.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 892545 $ $Date: 2009-12-20 02:04:17 +0100 (Sun, 20 Dec 2009) $
+ *
  */
 
 public abstract class ManagerBase implements Manager, MBeanRegistration {
@@ -69,8 +75,20 @@
 
     // ----------------------------------------------------- Instance Variables
 
+    private static final String devRandomSourceDefault;
+    static {
+        // - Use the default value only if it is a Unix-like system
+        // - Check that it exists 
+        File f = new File("/dev/urandom");
+        if (f.isAbsolute() && f.exists()) {
+            devRandomSourceDefault = f.getPath();
+        } else {
+            devRandomSourceDefault = null;
+        }
+    }
+
     protected DataInputStream randomIS=null;
-    protected String devRandomSource="/dev/urandom";
+    protected String devRandomSource = devRandomSourceDefault;
 
     /**
      * The default message digest algorithm to use if we cannot use
@@ -165,6 +183,15 @@
     protected int sessionAverageAliveTime;
 
 
+    protected static final int TIMING_STATS_CACHE_SIZE = 100;
+
+    protected LinkedList<SessionTiming> sessionCreationTiming =
+        new LinkedList<SessionTiming>();
+
+    protected LinkedList<SessionTiming> sessionExpirationTiming =
+        new LinkedList<SessionTiming>();
+
+
     /**
      * Number of sessions that have expired.
      */
@@ -180,7 +207,9 @@
     // Number of sessions created by this manager
     protected int sessionCounter=0;
 
-    protected int maxActive=0;
+    protected volatile int maxActive=0;
+
+    private final Object maxActiveUpdateLock = new Object();
 
     // number of duplicated session ids - anything >0 means we have problems
     protected int duplicates=0;
@@ -221,34 +250,17 @@
 
 
     private class PrivilegedSetRandomFile
-            implements PrivilegedAction<DataInputStream>{
-        
+            implements PrivilegedAction<Void>{
+
+        private final String s;
+
         public PrivilegedSetRandomFile(String s) {
-            devRandomSource = s;
+            this.s = s;
         }
-        
-        public DataInputStream run(){
-            try {
-                File f=new File( devRandomSource );
-                if( ! f.exists() ) return null;
-                randomIS= new DataInputStream( new FileInputStream(f));
-                randomIS.readLong();
-                if( log.isDebugEnabled() )
-                    log.debug( "Opening " + devRandomSource );
-                return randomIS;
-            } catch (IOException ex){
-                log.warn("Error reading " + devRandomSource, ex);
-                if (randomIS != null) {
-                    try {
-                        randomIS.close();
-                    } catch (Exception e) {
-                        log.warn("Failed to close randomIS.");
-                    }
-                }
-                devRandomSource = null;
-                randomIS=null;
-                return null;
-            }
+
+        public Void run(){
+            doSetRandomFile(s);
+            return null;
         }
     }
 
@@ -400,7 +412,12 @@
                 // Ignore
             }
             if (apr) {
-                setEntropy(new String(result));
+                try {
+                    setEntropy(new String(result, "ISO-8859-1"));
+                } catch (UnsupportedEncodingException ux) {
+                    // ISO-8859-1 should always be supported
+                    throw new Error(ux);
+                }
             } else {
                 setEntropy(this.toString());
             }
@@ -522,27 +539,49 @@
         // as a hack, you can use a static file - and generate the same
         // session ids ( good for strange debugging )
         if (Globals.IS_SECURITY_ENABLED){
-            randomIS = AccessController.doPrivileged(new PrivilegedSetRandomFile(s));
+            AccessController.doPrivileged(new PrivilegedSetRandomFile(s));
         } else {
-            try{
-                devRandomSource=s;
-                File f=new File( devRandomSource );
-                if( ! f.exists() ) return;
-                randomIS= new DataInputStream( new FileInputStream(f));
-                randomIS.readLong();
-                if( log.isDebugEnabled() )
-                    log.debug( "Opening " + devRandomSource );
-            } catch( IOException ex ) {
-                log.warn("Error reading " + devRandomSource, ex);
-                if (randomIS != null) {
-                    try {
-                        randomIS.close();
-                    } catch (Exception e) {
-                        log.warn("Failed to close randomIS.");
-                    }
+            doSetRandomFile(s);
+        }
+    }
+
+    private void doSetRandomFile(String s) {
+        DataInputStream is = null;
+        try {
+            if (s == null || s.length() == 0) {
+                return;
+            }
+            File f = new File(s);
+            if( ! f.exists() ) return;
+            if( log.isDebugEnabled() ) {
+                log.debug( "Opening " + s );
+            }
+            is = new DataInputStream( new FileInputStream(f));
+            is.readLong();
+        } catch( IOException ex ) {
+            log.warn("Error reading " + s, ex);
+            if (is != null) {
+                try {
+                    is.close();
+                } catch (Exception ex2) {
+                    log.warn("Failed to close " + s, ex2);
                 }
+                is = null;
+            }
+        } finally {
+            DataInputStream oldIS = randomIS;
+            if (is != null) {
+                devRandomSource = s;
+            } else {
                 devRandomSource = null;
-                randomIS=null;
+            }
+            randomIS = is;
+            if (oldIS != null) {
+                try {
+                    oldIS.close();
+                } catch (Exception ex) {
+                    log.warn("Failed to close RandomIS", ex);
+                }
             }
         }
     }
@@ -564,7 +603,7 @@
             long t1 = seed;
             char entropy[] = getEntropy().toCharArray();
             for (int i = 0; i < entropy.length; i++) {
-                long update = ((byte) entropy[i]) << ((i % 8) * 8);
+                long update = ((long) entropy[i]) << ((i % 8) * 8);
                 seed ^= update;
             }
             try {
@@ -750,6 +789,15 @@
         // Initialize random number generation
         getRandomBytes(new byte[16]);
         
+        // Ensure caches for timing stats are the right size by filling with
+        // nulls.
+        while (sessionCreationTiming.size() < TIMING_STATS_CACHE_SIZE) {
+            sessionCreationTiming.add(null);
+        }
+        while (sessionExpirationTiming.size() < TIMING_STATS_CACHE_SIZE) {
+            sessionExpirationTiming.add(null);
+        }
+
         if(log.isDebugEnabled())
             log.debug("Registering " + oname );
                
@@ -765,7 +813,11 @@
         sessions.put(session.getIdInternal(), session);
         int size = sessions.size();
         if( size > maxActive ) {
-            maxActive = size;
+            synchronized(maxActiveUpdateLock) {
+                if( size > maxActive ) {
+                    maxActive = size;
+                }
+            }
         }
     }
 
@@ -854,6 +906,11 @@
         session.setId(sessionId);
         sessionCounter++;
 
+        SessionTiming timing = new SessionTiming(session.getCreationTime(), 0);
+        synchronized (sessionCreationTiming) {
+            sessionCreationTiming.add(timing);
+            sessionCreationTiming.poll();
+        }
         return (session);
 
     }
@@ -931,7 +988,14 @@
      * @param session   The session to change the session ID for
      */
     public void changeSessionId(Session session) {
-        session.setId(generateSessionId());
+        String oldId = session.getIdInternal();
+        session.setId(generateSessionId(), false);
+        String newId = session.getIdInternal();
+        if (container instanceof ContainerBase) {
+            ((ContainerBase)container).fireContainerEvent(
+                    Context.CHANGE_SESSION_ID_EVENT,
+                    new String[] {oldId, newId});
+        }
     }
     
     
@@ -1107,7 +1171,9 @@
 
 
     public void setMaxActive(int maxActive) {
-        this.maxActive = maxActive;
+        synchronized (maxActiveUpdateLock) {
+            this.maxActive = maxActive;
+        }
     }
 
 
@@ -1159,6 +1225,91 @@
     }
 
 
+    /**
+     * Gets the current rate of session creation (in session per minute) based
+     * on the creation time of the previous 100 sessions created. If less than
+     * 100 sessions have been created then all available data is used.
+     * 
+     * @return  The current rate (in sessions per minute) of session creation
+     */
+    public int getSessionCreateRate() {
+        long now = System.currentTimeMillis();
+        // Copy current stats
+        List<SessionTiming> copy = new ArrayList<SessionTiming>();
+        synchronized (sessionCreationTiming) {
+            copy.addAll(sessionCreationTiming);
+        }
+        
+        // Init
+        long oldest = now;
+        int counter = 0;
+        int result = 0;
+        Iterator<SessionTiming> iter = copy.iterator();
+        
+        // Calculate rate
+        while (iter.hasNext()) {
+            SessionTiming timing = iter.next();
+            if (timing != null) {
+                counter++;
+                if (timing.getTimestamp() < oldest) {
+                    oldest = timing.getTimestamp();
+                }
+            }
+        }
+        if (counter > 0) {
+            if (oldest < now) {
+                result = (int) ((1000*60*counter)/(now - oldest));
+            } else {
+                result = Integer.MAX_VALUE;
+            }
+        }
+        return result;
+    }
+    
+
+    /**
+     * Gets the current rate of session expiration (in session per minute) based
+     * on the expiry time of the previous 100 sessions expired. If less than
+     * 100 sessions have expired then all available data is used.
+     * 
+     * @return  The current rate (in sessions per minute) of session expiration
+     */
+    public int getSessionExpireRate() {
+        long now = System.currentTimeMillis();
+        // Copy current stats
+        List<SessionTiming> copy = new ArrayList<SessionTiming>();
+        synchronized (sessionExpirationTiming) {
+            copy.addAll(sessionExpirationTiming);
+        }
+        
+        // Init
+        long oldest = now;
+        int counter = 0;
+        int result = 0;
+        Iterator<SessionTiming> iter = copy.iterator();
+        
+        // Calculate rate
+        while (iter.hasNext()) {
+            SessionTiming timing = iter.next();
+            if (timing != null) {
+                counter++;
+                if (timing.getTimestamp() < oldest) {
+                    oldest = timing.getTimestamp();
+                }
+            }
+        }
+        if (counter > 0) {
+            if (oldest < now) {
+                result = (int) ((1000*60*counter)/(now - oldest));
+            } else {
+                // Better than reporting zero
+                result = Integer.MAX_VALUE;
+            }
+        }
+        return result;
+    }
+
+
     /** 
      * For debugging: return a list of all session ids currently active
      *
@@ -1303,4 +1454,30 @@
     public void postDeregister() {
     }
 
+    // ----------------------------------------------------------- Inner classes
+    
+    protected static final class SessionTiming {
+        private long timestamp;
+        private int duration;
+        
+        public SessionTiming(long timestamp, int duration) {
+            this.timestamp = timestamp;
+            this.duration = duration;
+        }
+        
+        /**
+         * Time stamp associated with this piece of timing information in
+         * milliseconds.
+         */
+        public long getTimestamp() {
+            return timestamp;
+        }
+        
+        /**
+         * Duration associated with this piece of timing information in seconds.
+         */
+        public int getDuration() {
+            return duration;
+        }
+    }
 }
--- java/org/apache/catalina/Session.java.orig	2014-07-17 20:19:54.061738000 -0400
+++ java/org/apache/catalina/Session.java	2014-07-17 20:21:22.413985000 -0400
@@ -31,7 +31,7 @@
  * between requests for a particular user of a web application.
  *
  * @author Craig R. McClanahan
- * @version $Revision: 467222 $ $Date: 2006-10-24 05:17:11 +0200 (Tue, 24 Oct 2006) $
+ *
  */
 
 public interface Session {
@@ -111,7 +111,8 @@
 
 
     /**
-     * Set the session identifier for this session.
+     * Set the session identifier for this session and notifies any associated
+     * listeners that a new session has been created.
      *
      * @param id The new session identifier
      */
@@ -119,6 +120,17 @@
 
 
     /**
+     * Set the session identifier for this session and optionally notifies any
+     * associated listeners that a new session has been created.
+     *
+     * @param id        The new session identifier
+     * @param notify    Should any associated listeners be notified that a new
+     *                      session has been created? 
+     */
+    public void setId(String id, boolean notify);
+
+
+    /**
      * Return descriptive information about this Session implementation and
      * the corresponding version number, in the format
      * <code>&lt;description&gt;/&lt;version&gt;</code>.
--- java/org/apache/tomcat/util/security/PrivilegedGetTccl.java.orig	2014-07-17 18:58:41.876249000 -0400
+++ java/org/apache/tomcat/util/security/PrivilegedGetTccl.java	2014-07-17 19:33:08.643221000 -0400
@@ -0,0 +1,27 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.util.security;
+
+import java.security.PrivilegedAction;
+
+public class PrivilegedGetTccl implements PrivilegedAction<ClassLoader> {
+    public ClassLoader run() {
+        return Thread.currentThread().getContextClassLoader();
+    }
+}
+
+
--- java/org/apache/tomcat/util/security/PrivilegedSetTccl.java.orig	2014-07-17 18:58:41.880249000 -0400
+++ java/org/apache/tomcat/util/security/PrivilegedSetTccl.java	2014-07-17 19:31:16.471844000 -0400
@@ -0,0 +1,33 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tomcat.util.security;
+
+import java.security.PrivilegedAction;
+
+public class PrivilegedSetTccl implements PrivilegedAction<Void> {
+
+    private ClassLoader cl;
+
+    public PrivilegedSetTccl(ClassLoader cl) {
+        this.cl = cl;
+    }
+
+    public Void run() {
+        Thread.currentThread().setContextClassLoader(cl);
+        return null;
+    }
+}
\ No newline at end of file
