--- java/org/apache/tomcat/util/http/MimeHeaders.java.orig	2012-03-01 13:32:08.977332734 -0700
+++ java/org/apache/tomcat/util/http/MimeHeaders.java	2012-03-01 13:36:36.211240455 -0700
@@ -23,9 +23,6 @@
 
 import org.apache.tomcat.util.buf.MessageBytes;
 
-/* XXX XXX XXX Need a major rewrite  !!!!
- */
-
 /**
  * This class is used to contain standard internet message headers,
  * used for SMTP (RFC822) and HTTP (RFC2068) messages as well as for
@@ -79,11 +76,6 @@
  *  to avoid inside tomcat. The goal is to use _only_ MessageByte-based Fields,
  *  and reduce to 0 the memory overhead of tomcat.
  *
- *  TODO:
- *  XXX one-buffer parsing - for http ( other protocols don't need that )
- *  XXX remove unused methods
- *  XXX External enumerations, with 0 GC.
- *  XXX use HeaderName ID
  *  
  * 
  * @author dac@eng.sun.com
@@ -93,10 +85,11 @@
  */
 public class MimeHeaders {
     /** Initial size - should be == average number of headers per request
-     *  XXX  make it configurable ( fine-tuning of web-apps )
      */
     public static final int DEFAULT_HEADER_SIZE=8;
-    
+    protected static final int MAX_COUNT = 
+	      Integer.valueOf(System.getProperty("org.apache.tomcat.util.http.MimeHeaders.MAX_COUNT", "128")).intValue();
+
     /**
      * The header fields.
      */
@@ -216,6 +209,9 @@
         MimeHeaderField mh;
         int len = headers.length;
         if (count >= len) {
+				if (count >= MAX_COUNT) {
+				    throw new IllegalStateException("Header count exceeded allowed maximum: " + MAX_COUNT);
+				}
             // expand header list array
             MimeHeaderField tmp[] = new MimeHeaderField[count * 2];
             System.arraycopy(headers, 0, tmp, 0, len);
@@ -326,9 +322,7 @@
      * @param name the name of the header field to be removed
      */
     public void removeHeader(String name) {
-        // XXX
         // warning: rather sticky code; heavily tuned
-
         for (int i = 0; i < count; i++) {
             if (headers[i].getName().equalsIgnoreCase(name)) {
                 removeHeader(i--);
--- java/org/apache/tomcat/util/http/Parameters.java.orig	2012-03-28 12:04:18.587159798 -0600
+++ java/org/apache/tomcat/util/http/Parameters.java	2012-03-28 13:49:43.128836958 -0600
@@ -51,8 +51,11 @@
 
     UDecoder urlDec;
     MessageBytes decodedQuery=MessageBytes.newInstance();
+
     
     public static final int INITIAL_SIZE=4;
+    protected static final int MAX_COUNT = 
+        Integer.valueOf(System.getProperty("org.apache.tomcat.util.http.Parameters.MAX_COUNT", "512")).intValue();
 
     // Garbage-less parameter merging.
     // In a sub-request with parameters, the new parameters
@@ -166,9 +169,12 @@
 
     public void addParameterValues( String key, String[] newValues) {
         if ( key==null ) return;
+
         String values[];
         if (paramHashStringArray.containsKey(key)) {
             String oldValues[] = (String[])paramHashStringArray.get(key);
+				if (oldValues.length >= MAX_COUNT)
+					throw new IllegalStateException ("Parameter values exceeded allow maximum: " + MAX_COUNT);
             values = new String[oldValues.length + newValues.length];
             for (int i = 0; i < oldValues.length; i++) {
                 values[i] = oldValues[i];
@@ -177,6 +183,9 @@
                 values[i+ oldValues.length] = newValues[i];
             }
         } else {
+            if (paramHashStringArray.size() >=MAX_COUNT) {
+               throw new IllegalStateException("Parameter count exceeded allowed maximum: " + MAX_COUNT);
+				}
             values = newValues;
         }
 
@@ -309,16 +318,22 @@
     // until we test the new one
     private void addParam( String key, String value ) {
         if( key==null ) return;
+
         String values[];
         if (paramHashStringArray.containsKey(key)) {
             String oldValues[] = (String[])paramHashStringArray.
                 get(key);
+				if (oldValues.length >= MAX_COUNT)
+					throw new IllegalStateException ("Parameter values exceeded allow maximum: " + MAX_COUNT);
             values = new String[oldValues.length + 1];
             for (int i = 0; i < oldValues.length; i++) {
                 values[i] = oldValues[i];
             }
             values[oldValues.length] = value;
         } else {
+            if (paramHashStringArray.size() >=MAX_COUNT) {
+                throw new IllegalStateException("Parameter count exceeded allowed maximum: " + MAX_COUNT);
+				}
             values = new String[1];
             values[0] = value;
         }
