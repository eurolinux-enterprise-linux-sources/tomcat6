--- java/org/apache/coyote/ajp/AjpAprProcessor.java.orig	2014-04-09 16:11:49.965046000 -0400
+++ java/org/apache/coyote/ajp/AjpAprProcessor.java	2014-04-09 17:15:46.593934000 -0400
@@ -25,6 +25,8 @@
 import java.security.cert.CertificateFactory;
 import java.security.cert.X509Certificate;
 
+import javax.servlet.http.HttpServletResponse;
+
 import org.apache.coyote.ActionCode;
 import org.apache.coyote.ActionHook;
 import org.apache.coyote.Adapter;
@@ -664,6 +666,8 @@
         // Decode headers
         MimeHeaders headers = request.getMimeHeaders();
 
+        boolean contentLengthSet = false;
+
         int hCount = requestHeaderMessage.getInt();
         for(int i = 0 ; i < hCount ; i++) {
             String hName = null;
@@ -700,8 +704,15 @@
                     (hId == -1 && tmpMB.equalsIgnoreCase("Content-Length"))) {
                 // just read the content-length header, so set it
                 long cl = vMB.getLong();
-                if(cl < Integer.MAX_VALUE)
-                    request.setContentLength( (int)cl );
+                if (contentLengthSet) {
+                    response.setStatus(HttpServletResponse.SC_BAD_REQUEST);
+                    error = true;
+                } else {
+                    contentLengthSet = true;
+                    // Set teh content-length hearder for the request
+                    if (cl < Integer.MAX_VALUE)
+                        request.setContentLength( (int)cl);
+                }
             } else if (hId == Constants.SC_REQ_CONTENT_TYPE ||
                     (hId == -1 && tmpMB.equalsIgnoreCase("Content-Type"))) {
                 // just read the content-type header, so set it
--- java/org/apache/coyote/ajp/AjpProcessor.java.orig	2014-04-09 16:11:50.022032000 -0400
+++ java/org/apache/coyote/ajp/AjpProcessor.java	2014-04-09 17:15:56.499049000 -0400
@@ -27,6 +27,8 @@
 import java.security.cert.CertificateFactory;
 import java.security.cert.X509Certificate;
 
+import javax.servlet.http.HttpServletResponse;
+
 import org.apache.coyote.ActionCode;
 import org.apache.coyote.ActionHook;
 import org.apache.coyote.Adapter;
@@ -669,6 +671,8 @@
         // Decode headers
         MimeHeaders headers = request.getMimeHeaders();
 
+        boolean contentLengthSet = false;
+
         int hCount = requestHeaderMessage.getInt();
         for(int i = 0 ; i < hCount ; i++) {
             String hName = null;
@@ -705,8 +709,15 @@
                     (hId == -1 && tmpMB.equalsIgnoreCase("Content-Length"))) {
                 // just read the content-length header, so set it
                 long cl = vMB.getLong();
-                if(cl < Integer.MAX_VALUE)
-                    request.setContentLength( (int)cl );
+                if (contentLengthSet) {
+                    response.setStatus(HttpServletResponse.SC_BAD_REQUEST);
+                    error = true;
+                } else {
+                    contentLengthSet = true;
+                    // Set the content-length header for the request
+                    if(cl < Integer.MAX_VALUE)
+                        request.setContentLength( (int)cl );
+                }
             } else if (hId == Constants.SC_REQ_CONTENT_TYPE ||
                     (hId == -1 && tmpMB.equalsIgnoreCase("Content-Type"))) {
                 // just read the content-type header, so set it
--- java/org/apache/coyote/http11/Http11AprProcessor.java.orig	2014-04-09 16:11:50.053017000 -0400
+++ java/org/apache/coyote/http11/Http11AprProcessor.java	2014-04-09 19:22:29.503087000 -0400
@@ -1417,10 +1417,21 @@
 
         // Parse content-length header
         long contentLength = request.getContentLengthLong();
-        if (contentLength >= 0 && !contentDelimitation) {
-            inputBuffer.addActiveFilter
-                (inputFilters[Constants.IDENTITY_FILTER]);
-            contentDelimitation = true;
+        if (contentLength >= 0) {
+            if (contentDelimitation) {
+                // contentDelimitation being true at this point indicates
+                // that chunked encoding is being used but chunked 
+                // encoding should not be used with a content length. 
+                // RFC 2616, section 4.4,
+                // bullet 3 states Content-Length must be ignored in this
+                // case - so remove it.
+                headers.removeHeader("content-length");
+                request.setContentLength(-1);
+            } else {
+                inputBuffer.addActiveFilter
+                    (inputFilters[Constants.IDENTITY_FILTER]);
+                contentDelimitation = true;
+            }
         }
 
         MessageBytes valueMB = headers.getValue("host");
--- java/org/apache/coyote/http11/Http11NioProcessor.java.orig	2014-04-09 16:11:50.075033000 -0400
+++ java/org/apache/coyote/http11/Http11NioProcessor.java	2014-04-09 19:24:56.532600000 -0400
@@ -1433,10 +1433,21 @@
 
         // Parse content-length header
         long contentLength = request.getContentLengthLong();
-        if (contentLength >= 0 && !contentDelimitation) {
-            inputBuffer.addActiveFilter
-                (inputFilters[Constants.IDENTITY_FILTER]);
-            contentDelimitation = true;
+        if (contentLength >= 0) {
+            if (contentDelimitation) {
+                // contentDelimitation being true at this point indicates
+                // that chunked encoding is being used but chunked 
+                // encoding should not be used with a content length. 
+                // RFC 2616, section 4.4,
+                // bullet 3 states Content-Length must be ignored in this
+                // case - so remove it.
+                headers.removeHeader("content-length");
+                request.setContentLength(-1);
+            } else {
+                inputBuffer.addActiveFilter
+                    (inputFilters[Constants.IDENTITY_FILTER]);
+                contentDelimitation = true;
+            }
         }
 
         MessageBytes valueMB = headers.getValue("host");
--- java/org/apache/coyote/http11/Http11Processor.java.orig	2014-04-09 16:11:50.137029000 -0400
+++ java/org/apache/coyote/http11/Http11Processor.java	2014-04-09 19:24:15.885495000 -0400
@@ -1314,10 +1314,21 @@
 
         // Parse content-length header
         long contentLength = request.getContentLengthLong();
-        if (contentLength >= 0 && !contentDelimitation) {
-            inputBuffer.addActiveFilter
-                (inputFilters[Constants.IDENTITY_FILTER]);
-            contentDelimitation = true;
+        if (contentLength >= 0) {
+            if (contentDelimitation) {
+                // contentDelimitation being true at this point indicates
+                // that chunked encoding is being used but chunked 
+                // encoding should not be used with a content length. 
+                // RFC 2616, section 4.4,
+                // bullet 3 states Content-Length must be ignored in this
+                // case - so remove it.
+                headers.removeHeader("content-length");
+                request.setContentLength(-1);
+            } else {
+                inputBuffer.addActiveFilter
+                    (inputFilters[Constants.IDENTITY_FILTER]);
+                contentDelimitation = true;
+            }
         }
 
         MessageBytes valueMB = headers.getValue("host");
--- webapps/docs/changelog.xml.orig	2014-04-09 16:11:50.166000000 -0400
+++ webapps/docs/changelog.xml	2014-04-09 19:25:29.344721000 -0400
@@ -182,6 +182,10 @@
 		   Prevent NPEs when a socket is closed in non-error conditions after
 			sendfile processing when using the HTTP NIO connector. (markt)
 		</fix>
+        <fix>
+            Better adhereence to RFC2616 for content-length headers (markt)
+            CVE-2013-4286 patch applied by Red Hat
+        </fix>
     </changelog>
   </subsection>
   <subsection name="Jasper">
