--- webapps/docs/changelog.xml.orig	2013-02-11 09:42:36.664353488 -0700
+++ webapps/docs/changelog.xml	2013-02-11 11:07:14.539090591 -0700
@@ -36,9 +36,17 @@
 <section name="Tomcat 6.0.24 (jfclere)">
   <subsection name="Catalina">
     <changelog>
+	   <fix>
+	      Various improvements to the Digest authenticator including
+			<bug>52954</bug>, the disabling caching of an authenticated
+			user in the session by default, tracking server rather than
+			client nonces and better handling of stal nonce values. (markt)
+			Fix in tomcat6-6.0.36. Patch ported to 6.0.24 by Red Hat
+			rhbz 882010
+		</fix>
 	 	<add>
 		   CVE-2011-1184 
-			Add additional configurtion options to the DIGEST authenticator
+			Add additional configuration options to the DIGEST authenticator
 			(markt)
 		</add>
 	   <fix>
--- webapps/docs/config/valve.xml.orig	2013-02-11 09:42:52.221434862 -0700
+++ webapps/docs/config/valve.xml	2013-02-11 11:28:04.529866175 -0700
@@ -490,6 +490,12 @@
 
     <attributes>
 
+       <attribute name="cache" required="false">
+          <p>Should we cache authenticated Principals if the request is part 
+			 of an HTTP session? If not specified, the default value of 
+			 <code>false</code> will be used.</p>
+       </attribute>
+
       <attribute name="className" required="true">
         <p>Java class name of the implementation to use.  This MUST be set to
         <strong>org.apache.catalina.authenticator.DigestAuthenticator</strong>.</p>
@@ -518,6 +524,33 @@
         <code>true</code> will be used.</p>
       </attribute>
 
+      <attribute name="key" required="false">
+        <p>The secret key used by digest authentication. If not set, a secure
+        random value is generated. This should normally only be set when it is
+        necessary to keep key values constant either across server restarts
+        and/or across a cluster.</p>
+      </attribute>
+
+      <attribute name="nonceCacheSize" required="false">
+        <p>To protect against replay attacks, the DIGEST authenticator tracks
+        server nonce and nonce count values. This attribute controls the size
+        of that cache. If not specified, the default value of 1000 is used.</p>
+      </attribute>
+
+      <attribute name="nonceValidity" required="false">
+        <p>The time, in milliseconds, that a server generated nonce will be
+        considered valid for use in authentication. If not specified, the
+        default value of 300000 (5 minutes) will be used.</p>
+      </attribute>
+
+      <attribute name="opaque" required="false">
+        <p>The opaque server string used by digest authentication. If not set, a
+        random value is generated. This should normally only be set when it is
+        necessary to keep opaque values constant either across server restarts
+        and/or across a cluster.</p>
+      </attribute>
+      		
+
       <attribute name="securePagesWithPragma" required="false">
         <p>Controls the caching of pages that are protected by security
         constraints. Setting this to <code>false</code> may help work around
@@ -527,6 +560,14 @@
         If not set, the default value of <code>true</code> will be used.</p>
       </attribute>
 
+      <attribute name="validateUri" required="false">
+        <p>Should the URI be validated as required by RFC2617? If not specified,
+        the default value of <code>true</code> will be used. This should
+        normally only be set when Tomcat is located behind a reverse proxy and
+        the proxy is modifying the URI passed to Tomcat such that DIGEST
+        authentication always fails.</p>
+      </attribute>
+
     </attributes>
 
   </subsection>
--- java/org/apache/catalina/authenticator/DigestAuthenticator.java.orig	2013-02-11 09:42:25.191292933 -0700
+++ java/org/apache/catalina/authenticator/DigestAuthenticator.java	2013-02-11 11:51:50.984031391 -0700
@@ -27,6 +27,7 @@
 import java.util.Map;
 import java.util.StringTokenizer;
 
+import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 
 import org.apache.catalina.LifecycleException;
@@ -78,6 +79,7 @@
 
     public DigestAuthenticator() {
         super();
+		  setCache(false);
         try {
             if (md5Helper == null)
                 md5Helper = MessageDigest.getInstance("MD5");
@@ -97,15 +99,15 @@
     protected static MessageDigest md5Helper;
 
 	 /**
-	  * List of the client nonce values currently being tracked
+	  * List of the server nonce values currently being tracked
 	  */
-	 protected Map<String, NonceInfo> cnonces;
+	 protected Map<String, NonceInfo> nonces;
 
 	 /**
-	  * Maximum number of client nonces to keep in the cache. If not specified,
+	  * Maximum number of server nonces to keep in the cache. If not specified,
 	  * the default value of 1000 is used
 	  */
-	 protected int cnonceCacheSize = 1000;
+	 protected int nonceCacheSize = 1000;
 
 
     /**
@@ -146,12 +148,12 @@
 
 	// ------------ Public Methods
 
-	public int getCnonceCacheSize() {
-		return cnonceCacheSize;
+	public int getNonceCacheSize() {
+		return nonceCacheSize;
 	}
 
-	public void setCnonceCacheSize(int cnonceCacheSize) {
-		this.cnonceCacheSize = cnonceCacheSize;
+	public void setNonceCacheSize(int nonceCacheSize) {
+		this.nonceCacheSize = nonceCacheSize;
 	}
 
 	public String getKey() {
@@ -250,19 +252,19 @@
         // Validate any credentials already included with this request
         String authorization = request.getHeader("authorization");
 		  DigestInfo digestInfo = new DigestInfo(getOpaque(), getNonceValidity(),
-		  	getKey(), cnonces, isValidateUri());
+		  	getKey(), nonces, isValidateUri());
         if (authorization != null) {
-			  if (digestInfo.validate(request, authorization, config)) {
-				  principal = digestInfo.authenticate(context.getRealm());
-			  }
-
-            if (principal != null) {
-                String username = parseUsername(authorization);
-                register(request, response, principal,
-                         Constants.DIGEST_METHOD,
-                         username, null);
-                return (true);
-            }
+			  if (digestInfo.parse(request, authorization)) {
+				  if (digestInfo.validate(request, config)) {
+				  	principal = digestInfo.authenticate(context.getRealm());
+				  }
+			  	  if (principal != null && !digestInfo.isNonceStale()) {
+				     register(request, response, principal,
+				  	     HttpServletRequest.DIGEST_AUTH,
+					     digestInfo.getUsername(), null);
+				  	  return true;
+			 	  }
+           }
         }
 
         // Send an "unauthorized" response and an appropriate challenge
@@ -288,6 +290,8 @@
      * can be identified, return <code>null</code>
      *
      * @param authorization Authorization string to be parsed
+	  *
+	  * @deprecated unused. Will be removed in Tomcat 8.0.x
      */
     protected String parseUsername(String authorization) {
 
@@ -332,7 +336,7 @@
         } else if (quotedString.length() > 2) {
             return quotedString.substring(1, quotedString.length() - 1);
         } else {
-            return new String();
+            return "";
         }
     }
 
@@ -361,10 +365,14 @@
         synchronized (md5Helper) {
             buffer = md5Helper.digest(ipTimeKey.getBytes());
         }
-
-        return  currentTime + ":" + md5Encoder.encode(buffer);
-    }
-
+		   String nonce = currentTime + ":" + md5Encoder.encode(buffer);
+		   NonceInfo info = new NonceInfo(currentTime, 100);
+		   synchronized (nonces) {
+		          nonces.put(nonce, info);
+		   }
+		  
+		   return nonce;
+		  }
 
     /**
      * Generates the WWW-Authenticate header.
@@ -436,7 +444,7 @@
 			setOpaque(generateSessionId());
 		}
 
-		cnonces = new LinkedHashMap<String, DigestAuthenticator.NonceInfo>() {
+		nonces = new LinkedHashMap<String, DigestAuthenticator.NonceInfo>() {
 
 			private static final long serialVersionUID = 1L;
 			private static final long LOG_SUPPRESS_TIME = 5 * 60 * 1000;
@@ -448,7 +456,7 @@
 				Map.Entry<String, NonceInfo> eldest) {
 				// This is called from a sync so keep it simple
 				long currentTime = System.currentTimeMillis();
-				if (size() > getCnonceCacheSize()) {
+				if (size() > getNonceCacheSize()) {
 					if (lastLog < currentTime &&
 						currentTime - eldest.getValue().getTimestamp() <
 						getNonceValidity()) {
@@ -466,10 +474,10 @@
 
 	 private static class DigestInfo {
 		 
-		 private String opaque;
-		 private long nonceValidity;
-		 private String key;
-		 private Map<String, NonceInfo> cnonces;
+		 private final String opaque;
+		 private final long nonceValidity;
+		 private final String key;
+		 private final Map<String, NonceInfo> nonces;
 		 private boolean validateUri = true;
 
 		 private String userName = null;
@@ -481,20 +489,24 @@
 		 private String cnonce = null;
 		 private String realmName = null;
 		 private String qop = null;
+		 private String opaqueReceived;
 
 		 private boolean nonceStale = false;
 
 		 public DigestInfo(String opaque, long nonceValidity, String key,
-		  	Map<String, NonceInfo> cnonces, boolean validateUri) {
+		  	Map<String, NonceInfo> nonces, boolean validateUri) {
 			 this.opaque = opaque;
 			 this.nonceValidity = nonceValidity;
 			 this.key = key;
-			 this.cnonces = cnonces;
+			 this.nonces = nonces;
 			 this.validateUri = validateUri;
 		 }
 
-		 public boolean validate(Request request, String authorization,
-		 	LoginConfig config) {
+		 public String getUsername() {
+			 return userName;
+		 }
+
+		 public boolean parse(Request request, String authorization) {
 			 // Validate the authorization credentials format
 			 if (authorization == null) {
 				 return false;
@@ -508,7 +520,6 @@
           String[] tokens = authorization.split(",(?=(?:[^\"]*\"[^\"]*\")+$)");
 			 
 			 method = request.getMethod();
-			 String opaque = null;
 
 			 for (int i = 0; i < tokens.length; i++) {
 				 String currentToken = tokens[i];
@@ -558,10 +569,13 @@
 				}
 
 				if ("opaque".equals(currentTokenName)) {
-					opaque = removeQuotes(currentTokenValue);
+					opaqueReceived = removeQuotes(currentTokenValue);
 				}
 			 }
+			 return true;
+		 }
 
+		 public boolean validate(Request request, LoginConfig config) {
 			 if ( (userName == null) || (realmName == null) || (nonce == null)
 				 || (uri == null) || (response == null) ) {
 				 return false;
@@ -577,7 +591,23 @@
 					 uriQuery = request.getRequestURI() + "?" + query;
 				 }
 				 if (!uri.equals(uriQuery)) {
-					 return false;
+					 // Some clients (older Android) use an absolute URI for
+					 // DIGEST but a relative URI in the request line.
+					 // 2.3.5 < fixed Android version <= 4.0.3
+					 String host = request.getHeader("host");
+					 String scheme = request.getScheme();
+					 if (host != null && !uriQuery.startsWith(scheme)) {
+					    StringBuilder absolute = new StringBuilder();
+					    absolute.append(scheme);
+					    absolute.append("://");
+					    absolute.append(host);
+					    absolute.append(uriQuery);
+					    if (!uri.equals(absolute.toString())) {
+					           return false;
+					    }
+					 } else {
+					    return false;
+					 }
 				 }
 			 }
 
@@ -592,7 +622,7 @@
 
 
 			// Validate the opaque string
-			if (!this.opaque.equals(opaque)) {
+			if (!this.opaque.equals(opaqueReceived)) {
 				return false;
 			}
 
@@ -611,7 +641,9 @@
 			long currentTime = System.currentTimeMillis();
 			if (( currentTime - nonceTime) > nonceValidity) {
 				nonceStale = true;
-				return false;
+				synchronized (nonces) {
+					nonces.remove(nonce);
+				}
 			}
 			String serverIpTimeKey =
 				request.getRemoteAddr() + ":" + nonceTime + ":" + key;
@@ -630,7 +662,7 @@
 			}
 
 			// Validate cnonce and nc
-			// Check if presence of nc and nonce is consistent with presence
+			// Check if presence of nc and Cnonce is consistent with presence
 			// of qop
 			if (qop == null) {
 				if (cnonce != null || nc!= null) {
@@ -640,9 +672,11 @@
 				if (cnonce == null || nc == null) {
 					return false;
 				}
-				if (nc.length() != 8) {
+			  // RFC 2617 says nc must be 8 digits long. Older Android clients
+			  // use 6. 2.3.5 < fixed Android version <= 4.0.3
+			  if (nc.length() < 6 || nc.length() > 8) {				
 					return false;
-				}
+			  }
 				long count;
 				try {
 					count = Long.parseLong(nc, 16);
@@ -650,21 +684,18 @@
 					return false;
 				}
 				NonceInfo info;
-				synchronized (cnonces){
-					info = cnonces.get(cnonce);
+				synchronized (nonces){
+					info = nonces.get(nonce);
 				}
 				if (info == null) {
-					info = new NonceInfo();
+              // Nonce is valid but not in cache. It must have dropped out
+              // of the cache - force a re-authentication
+              nonceStale = true;					
 				} else {
-					if (count <= info.getCount()) {
+					if (!info.nonceCountValid(count)) {
 						return false;
 					}
 				}
-				info.setCount(count);
-				info.setTimestamp(currentTime);
-				synchronized (cnonces) {
-					cnonces.put(cnonce, info);
-				}
 			}
 			return true;
 		 }
@@ -690,18 +721,33 @@
 	 }
 
 	 private static class NonceInfo {
-		 private volatile long count;
 		 private volatile long timestamp;
-
-		 public void setCount(long l) {
-			 count = l;
-		 }
-		 public long getCount() {
-			 return count;
+		 private volatile boolean seen[];
+		 private volatile int offset;
+		 private volatile int count = 0;
+
+		 public NonceInfo(long currentTime, int seenWindowSize) {
+			 this.timestamp = currentTime;
+			 seen = new boolean[seenWindowSize];
+			 offset = seenWindowSize / 2;
 		 }
-		 public void setTimestamp(long l) {
-			 timestamp = l;
+
+		 public synchronized boolean nonceCountValid(long nonceCount) {
+          if ((count - offset) >= nonceCount ||
+               (nonceCount > count - offset + seen.length)) {
+              return false;
+          }
+          int checkIndex = (int) ((nonceCount + offset) % seen.length);
+          if (seen[checkIndex]) {
+            return false;
+          } else {
+              seen[checkIndex] = true;
+              seen[count % seen.length] = false;
+              count++;
+              return true;
+          }
 		 }
+
 		 public long getTimestamp() {
 			 return timestamp;
 		 }
